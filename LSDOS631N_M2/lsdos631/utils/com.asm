; ***************************************************************; * Filename: COM/ASM						*; * Revision: 06.03.01						*; * Rev Date: 08 Dec 97						*; ***************************************************************; * RS-232 Driver for LS-DOS					*; *								*; ***************************************************************;	TITLE	<COM/DVR - LS-DOS 6.3>;*=*=*;       Model II Change Log;; 02/23/83 - Changed wakeup vectoring to return:;               C = character, if available;               A = STATUS port image;               Z = character received; 05/20/83 - relocate to HIGH$ if no room in driver area; 05/25/83 - fixed SFLAG calculation to pt to SFLAG;;*=*=*INTVC$	EQU	03EH		;interrupt tableRSSERVA	EQU	INTVC$+4	;receive serviceA addressRSSERVB	EQU	INTVC$+6	;receive serviceB address$CTC0	EQU	0F0H		;counter-timer-controller$CTC1	EQU	0F1H$CTC2	EQU	0F2H$CTCX	EQU	000H		;dummy for channel B$SIOA	EQU	0F6H		;SIOA base port$SIOB	EQU	0F7H		;SIOB base port;ETX	EQU	03LF	EQU	10CR	EQU	13;*GET	BUILDVER	IF	@MOD4*GET	COPYCOM			; Copyright message	ENDIF	IF	@MOD2	IF	@BLD631B*GET	COPYCOM	ELSE	COM	'<*(C) 1982,3,4,6 by LSI*>'	ENDIF	ENDIF*GET	SVCMAC			; System SVC Macros;	ORG	2400HBEGIN	IF	@MOD4	@@CKBRKC	JR	Z,BEGINA	; Continue if no BREAK	LD	HL,-1	RET			; Return with abort code;BEGINA	ENDIF	PUSH	DE		; Save DCT address	POP	IX		;   in index reg	LD	(CLDCB),DE	;   and in driver header	IF	@MOD2;;	check if user specified port address;CKSTR	LD	A,(HL)		;get input	INC	HL		;bump pointer	CP	' '		;nil?	JR	Z,CKSTR		;yes, ignore them	CP	0DH		;carriage return?	JR	Z,USENAME	;port from name	CP	'('		;param start?	JP	NZ,PRMERR	;param error if not!	DEC	HL		;correct pointer	LD	DE,PRMTBL	;parameter table	@@PARAM			;evaluate params	JP	NZ,PRMERR	;go if error!	LD	A,(PRESP)	;get response byte	OR	A		;anything?	JR	Z,USENAME	;nope, use name for port	LD	DE,(PDATA)	;get input	INC	D		;check msb	DEC	D		;D<>0?	JP	NZ,PRMERR	;go if >256!	LD	A,E		;get lsb	OR	A		;0?	JP	Z,PRMERR	;port=0?	CP	3		;1/2?	JP	NC,PRMERR	;go if wrong	JR	BEG0		;continue;;	use device name to specify port;USENAME	LD	A,(IX+7)	;get last char name	CP	' '		;last char blank?	JR	NZ,BEG0		;go if not	LD	A,(IX+6)	;else fetch first charBEG0	AND	1		;use char as address;;	fetch hardware address' for SIO ports;	LD	BC,RSSERVA	;interrupt vector address	LD	DE,$CTC0<8+$CTC1	;CTC ports	LD	HL,'L'<8+$SIOA	;ID + base port	JR	NZ,BEG1		;go if one;	LD	BC,RSSERVB	;interrupt vector	LD	DE,$CTC2<8+$CTCX	;CTC ports	LD	HL,'M'<8+$SIOB	;ID + base port;BEG1	LD	(INTVC),BC	;save vector	LD	A,H		;get ascii ID	LD	(MODNAME),A	;save module name postfix	LD	(MODNAM2),A	;save into prefix	LD	A,L		;get base port	LD	(BASPORT),A	;save into data table	LD	(CTCPORT),DE	;save CTC ports;	ENDIF	LD	HL,HELLO$	; Welcome the user	@@DSPLY;;	Check if entry from SET command;	@@FLAGS			; IY => flag table base	BIT	3,(IY+'C'-'A')	; System request?	JP	Z,VIASET	; "Install with set...;;	Grab system dependent vectors;	PUSH	IY		; Set DE to flag base	POP	DE	LD	HL,'K'-'A'	; KFLAG$	ADD	HL,DE	LD	(KFLAG),HL	; Save keyboard flag location	LD	HL,'S'-'A'	; SFLAG$	ADD	HL,DE	LD	(SFLAG),HL	; Save system flag location	IF	@MOD4	LD	HL,'W'-'A'	; WRINT$	ADD	HL,DE	LD	(WRINT),HL	; Save Int mask	LD	(INIT+1),HL	LD	HL,10-44	; INTVC$+10	ADD	HL,DE	LD	(INTVC),HL	; Save for receive int vector	ENDIF;*=*=*;       Move @ICNFG vector into driver;*=*=*	LD	A,(IY+28)	; Get current opcode	LD	(LINK),A	; Save in driver	LD	L,(IY+29)	; Get curent address	LD	H,(IY+30)	LD	(LINK+1),HL	; Put in driver;;	Check if driver is already resident;	LD	DE,CL$		; Check if driver is	@@GTMOD			;   already resident	EX	DE,HL		; Put DCB in HL	JR	NZ,NOTRES;;	Make sure that the new DCB is same as the old;	LD	C,(HL)		; Get DCB pointer LSB	INC	HL	LD	B,(HL)		; Get DCB pointer MSB	LD	HL,6		; Get old DCB name &	ADD	HL,BC		;   stuff into error	LD	A,(HL)		;   message in case	IF	@MOD4	INC	L		;   a different DCB	ENDIF	IF	@MOD2	INC	HL		;   a different DCB	ENDIF	LD	H,(HL)		;   is referenced	LD	L,A	LD	(DCBNAM$),HL	; Stuff message with spec	LD	HL,(CLDCB)	; Get DCB existing DCB	OR	A		;   pointer	SBC	HL,BC		; Same pointer?	JP	NZ,DCBERR	; Can't install if different	JP	ISRES;;;NOTRES	LD	DE,'IK'	@@GTDCB			; Locate low memory ptr	JP	NZ,IOERR	; Go if not found	IF	@MOD4	DEC	L	LD	D,(HL)		; Get pointer to the	DEC	L		;   start of free	ENDIF	IF	@MOD2	DEC	HL	LD	D,(HL)		; Get pointer to the	DEC	HL		;   start of free	ENDIF	LD	E,(HL)		;   low core	LD	(LCPTR+1),HL	; Save for later	LD	HL,CLEND-CLDVR-1	ADD	HL,DE		; Start + driver length	LD	(SVEND+1),HL	LD	BC,1300H	; Max addr + 1	XOR	A	SBC	HL,BC		; See if room low	JR	C,PUTLOW	;   and install there if so;;	Check if high memory is available;	BIT	0,(IY+'C'-'A')	; Memory frozen?	JP	NZ,NOROOM	; Can't install if so	LD	HL,0	LD	B,L		; Get HIGH$	@@HIGH$	LD	(SVEND+1),HL	; Top of driver	OR	A	LD	BC,CLEND-CLDVR	; Minus length	SBC	HL,BC	LD	B,00H	PUSH	HL	@@HIGH$			; Is new HIGH$	POP	HL	INC	HL		; Plus one is start	LD	(HCPTR),HL	; Save it	LD	HL,HCPTR	;   and point to it	LD	(LCPTR+1),HL	LD	A,0FFH		; Flag Himem used	LD	(HGHFLG),A;;	Relocate internal references in driver;PUTLOW	PUSH	IX		; Save the DCB	LD	IX,RELTAB	; Point to relocation tableSVEND	LD	HL,$-$		; Find distance to move	LD	(CLDVR+2),HL	; Set last byte used	LD	DE,CLEND-1	OR	A		; Clear carry	SBC	HL,DE	LD	B,H		; Move to BC	LD	C,L;	IF	@MOD4	LD	A,TABLEN	; Get table lengthRLOOP	LD	L,(IX+00H)	; Get address to change	LD	H,(IX+01H)	LD	E,(HL)		; Get address	INC	HL	LD	D,(HL)	EX	DE,HL		; Offset it	ADD	HL,BC	EX	DE,HL	LD	(HL),D		; Put it back	DEC	HL	LD	(HL),E	INC	IX	INC	IX	DEC	A	JR	NZ,RLOOP	; Loop until done	POP	IX		; Get the DCB back	ENDIF;	IF	@MOD2RLOOP	LD	L,(IX)		;Get address to change	LD	H,(IX+1)	LD	A,H		;check for term	OR	L		;=0000?	JR	Z,RELEND	;yes, go!	LD	A,(HL)		;get LSB address	ADD	A,C		;add lsb offset	LD	(HL),A		;update	INC	HL		;bump table	LD	A,(HL)		;get MSB address	ADC	A,B		;add msb offset	LD	(HL),A		;update	INC	IX		;bump relo table	INC	IX		;2 bytes each	JR	RLOOP		;go next valueRELEND	POP	IX		;Restore DCB	ENDIF;;	Set up @ICNFG for boot up configuration;	LD	HL,INIT		; Get (relocated)RX01	EQU	$-2	LD	(IY+29),L	;   init address & put	LD	(IY+30),H	;   into system ICNFG area	LD	A,0C3H		; Get JP instruction	LD	(IY+28),A	; Turn on ICNFG;;	Move the driver into position;LCPTR	LD	HL,$-$		; Low core or himem pointer	LD	E,(HL)	IF	@MOD4	INC	L	ENDIF	IF	@MOD2	INC	HL	ENDIF	LD	D,(HL)	PUSH	DE		; Save start	LD	HL,CLDVR	LD	BC,CLEND-CLDVR	; Calc driver length	LDIR			; Move into place	LD	HL,(LCPTR+1)	; If driver went low,	LD	(HL),E		;   need to update new	IF	@MOD4	INC	L		;   driver zone pointer	ENDIF	IF	@MOD2	INC	HL		;   driver zone pointer	ENDIF	LD	(HL),D;	IF	@MOD4	LD	HL,LINKRX14	EQU	$-2	LD	E,(HL)		; Save what's there now	LD	(HL),0C9H	; Stuff a return	PUSH	HL		; Save address for later;;	Initialize the driver;	DI	LD	HL,RECVINTRX02	EQU	$-2	LD	($-$),HLINTVC	EQU	$-2	LD	HL,$-$WRINT	EQU	$-2	SET	5,(HL)	CALL	INITRX11	EQU	$-2	EI;	POP	HL		; Get Link back	LD	(HL),E		; Replace our RET inst	ENDIF;	IF	@MOD2	IF	@BLD631	LD	HL,LINKRX26	EQU	$-2	LD	E,(HL)		; Save what's there now	LD	(HL),0C9H	; Stuff a return	PUSH	HL		; Save address for later	PUSH	DE	ENDIF	PUSH	IX		;save	CALL	INIT		;init deviceRX02	EQU	$-2	POP	IX		;restore	IF	@BLD631	POP	DE	POP	HL		; Get Link back	LD	(HL),E		; Replace our RET inst	ENDIF;	ENDIF;	POP	DE		; Pop filter start;ISRES	LD	HL,CLACT$	; Advise COM/DVR installed	LD	(IX+00H),07H	; Init DCB type to "C/P/G"	LD	(IX+01H),E	;   & stuff the driver	LD	(IX+02H),D	;   address	@@LOGOT	LD	A,$-$		; Did it use high memory?HGHFLG	EQU	$-1	OR	A		; NZ if high	JR	Z,NTHGH	LD	HL,HMEM$	; "Driver in himem...	@@LOGOTNTHGH	LD	HL,0		; Init no error code	RET			;   and return;;	Error exits;	IF	@MOD2PRMERR	LD	HL,PRMERR$	;'parameter error'	DB	0DDH	ENDIFVIASET	LD	HL,VIASET$	; "Install with SET	DB	0DDHDCBERR	LD	HL,DCBERR$	; "Driver being used already	DB	0DDHNOROOM	LD	HL,NOROOM$	; "Memory frozen	@@LOGOT	LD	HL,-1		; Set abort code	IF	@MOD4	@@CKBRKC		; Clear any BREAK	ENDIF	RET;;	I/O Error handler;IOERR	LD	L,A		; Error code to HL	LD	H,00H	OR	0C0H		; Short msg, return	LD	C,A	@@ERROR			; Show error	IF	@MOD4	@@CKBRKC		; Clear any BREAK	ENDIF	RET;;	Messages and data tables;HCPTR	DW	0		; Save start if going to HIGH$CL$	DB	'$C'		;device nameMODNAME	DB	'L',ETX		;device modifier;	IF	@MOD4HELLO$	DB	'RS-232 Driver'	ENDIF	IF	@MOD2HELLO$	DB	'COM'	ENDIF*GET	CLIENT;NOROOM$	DB	'No memory space available',CRDCBERR$	DB	'Driver already attached to *'DCBNAM$	DB	'xx',CRCLACT$	DB	'COM driver is now resident',CR	IF	@MOD2PRMERR$	DB	'Parameter error',CR	ENDIFVIASET$	DB	'Must install via SET',CRHMEM$	DB	LF,'Note: '	DB	'driver installed in high memory',CR;	IF	@MOD4@WRINT	EQU	0E0HWRINT$	EQU	80H;MASRES	EQU	0E8H		; RS-232 PortsMODSTAT	EQU	0E8HBAUDSET	EQU	0E9HUARTCTL	EQU	0EAHUARTST	EQU	0EAHDATAREG	EQU	0EBH	ENDIF;	IF	@MOD2;;	parameter table;PRMTBL	DB	80H		;extended params	DB	4+90H		;length + numeric	DM	'PORT'PRESP	DB	0		;response byte	DW	PDATA		;data addressPDATA	DW	0		;response data here;;	relocation table;RELTAB	DW	RX01,RX02,RX03,RX04,RX05,RX06,RX07	DW	RX08,RX09,RX10,RX11,RX12,RX13,RX14	DW	RX15,RX16,RX17,RX18,RX19,RX20,RX21	DW	RX22,RX23,RX24,RX25	IF	@BLD631	DW	RX26	ENDIF	DW	0	ENDIF;;	The actual driver;CLDVR	EQU	$	JR	CLBGN		; Branch around linkage	DW	CLEND		; Last byte used	DB	3,'$CL'MODNAM2	EQU	$-1CLDCB	DW	$-$	DW	0CLDATA$	EQU	$MSMASK	EQU	$-CLDATA$CLDATA$	DB	0;;	UART Control Port image;;	Bit 7:	1 = Even parity, 0 = Odd parity;	Bit 6,5: Word length (00=5,10=6,01=7,11=8);	Bit 4:	1 = 2 stop bits, 0 = 1 stop bit;	Bit 3:	1 = disable parity, 0 = enable parity;	Bit 2:	1 = enable TX data, 0 = break;	Bit 1:	0 = Data Terminal Ready;	Bit 0:	0 = Request To Send;UCIMAGE	EQU	$-CLDATA$	IF	@MOD4	DB	0A5H		; 10100101 = 7E1, RTS	ENDIF	IF	@MOD2	DB	10100100B	; 7E1, no RTS	ENDIF;BAUD	EQU	$-CLDATA$BAUDRT	DB	55H		; Init 300 baud;LOGBRK	EQU	$-CLDATA$	DB	03H		; Default is Ctl-CCLFLG	EQU	$-CLDATA$	DB	00H		; Init no char in buf	IF	@MOD2BPORT	EQU	$-CLDATA$	DB	0		;base I/O portBASPORT	EQU	$-1CTC2	EQU	$-CLDATA$	;CTC 1	DB	0CTC1	EQU	$-CLDATA$	;CTC 2	DB	0CTCPORT	EQU	$-2	ENDIFCLBUF	EQU	$-CLDATA$	DB	00H		; One-char buffer	IF	@MOD2R5MASK	EQU	$-CLDATA$	;register 5 mask	DB	0WORD	EQU	$-CLDATA$	;word length mask	DB	-1		;8 bits	ENDIF;;	CL initialization routine.  Set up DR interrupt;	vector and initialize the hardware;	IF	@MOD4INIT	LD	A,($-$)		; Get WRINT	OUT	(@WRINT),A	CALL	CTL2RX03	EQU	$-2LINK	RET			; Link back	ENDIF;	IF	@MOD2INIT	LD	HL,RECVINT	;receive addressRX03	EQU	$-2	LD	($-$),HL	;pass to interrupt vectorINTVC	EQU	$-2	LD	A,(INTVC$)	;LSB SIOA interrupt	LD	(ITABLE+11),A	;save addressRX04	EQU	$-2	ADD	A,16		;offset to SIOB interrupt	LD	(ITABLE+18),A	;save addressRX05	EQU	$-2	CALL	CTL2RX06	EQU	$-2LINK	RET			;Link back	ENDIF;	DB	0,0	IF	@MOD4;;	Initialize the UART and BRG;	(relocated here for JR);CTL2	LD	BC,(CLDATA$+UCIMAGE)	; Vals from DCBRX04	EQU	$-2	OUT	(MASRES),A	; Reprime UART	LD	A,C	OUT	(UARTCTL),A	LD	A,B	OUT	(BAUDSET),A	RET	ENDIF;CLBGN	LD	IX,CLDATA$	; Point to data area	IF	@MOD4RX05	EQU	$-2	JR	C,RECV		; Go if @GET	JR	Z,SEND		; Go if @PUT	ENDIF	IF	@MOD2RX07	EQU	$-2	JP	C,RECV		; Go if @GETRX08	EQU	$-2	JP	Z,SEND		; Go if @PUTRX09	EQU	$-2	ENDIF	LD	A,C		; Get @CTL byte	OR	A		; @CTL 00?	IF	@MOD4	JR	Z,CANISND	; Go if so	ENDIF	IF	@MOD2	JP	Z,CANISND	; Go if soRX10	EQU	$-2	ENDIF	DEC	A	IF	@MOD4	JR	Z,CTL1		; Go if CTL 01	ENDIF	IF	@MOD2	JP	Z,CTL1		; Go if soRX11	EQU	$-2	ENDIF	DEC	A	JR	Z,CTL2		; CTL 02 "init uart"	CP	4-2		; Wakeup feature?	IF	@MOD4	JR	Z,CTL4		; Go if wakeup	ENDIF	IF	@MOD2	JP	Z,CTL4		;Go if wakeup featureRX12	EQU	$-2	ENDIF	XOR	A	RET;	IF	@MOD2;*=*=*;       Initialize the UART & BRG;*=*=*CTL2	PUSH	IY		;save	LD	IY,ITABLE	;init tableRX13	EQU	$-2	LD	IX,CLDATA$	;start data tableRX14	EQU	$-2;;	init SIO/CTC port addresses;	LD	A,(IX+BPORT)	;get base port	LD	(IY+2),A	;save into table	LD	A,(IX+CTC1)	;get CTC 1 port	LD	(IY+15),A	;save into table	LD	A,(IX+CTC2)	;get CTC 2 port	LD	(IY+20),A	;save into table;;	init baud rate configuration;	LD	A,(IX+BAUD)	;get baud rate	AND	0FH		;low 4 bits	ADD	A,A		;2 byte table	LD	HL,BAUDTBL	;baud rate tableRX15	EQU	$-2	ADD	A,L		;add to lsb	LD	L,A		;update lsb	JR	NC,$+3		;go if no overflow	INC	H		;bump msb	LD	A,(HL)		;get counter select	LD	(IY+16),A	;RX baud	LD	(IY+21),A	;TX baud	INC	HL		;bump pointer	LD	A,(HL)		;get count	LD	(IY+17),A	;RX count	LD	(IY+22),A	;TX count;;	init word length;	LD	A,(IX+UCIMAGE)	;get image	RLCA			;align bits 6,5 => 1,0	RLCA	RLCA	AND	3		;low 2 bits	JP	PE,$+5		;go if 5 or 8RX16	EQU	$-2	XOR	3		;change 6/7 => 7/6	ADD	A,5		;add offset	LD	B,A		;init loop	XOR	A		;init word byteSIO1	SCF			;set bit	RLA			;move into accum	DJNZ	SIO1		;go for word length	LD	(IX+WORD),A	;save word length mask	LD	A,(IX+UCIMAGE)	;get config byte	AND	60H		;bits 6/5 only	OR	8		;TX enable	BIT	1,(IX+UCIMAGE)	;DTR?	JR	NZ,$+4		;go if not	OR	80H		;enable DTR	BIT	0,(IX+UCIMAGE)	;RTS?	JR	NZ,$+4		;go if not	OR	02H		;enable RTS	LD	(IY+9),A	;DTR,TX enable,RTS,length	LD	(IX+R5MASK),A	;save for CTL calls	RLCA			;align for RX	OR	01H		;RX enable	LD	(IY+7),A	;save into RX table;;	init parity;	LD	A,40H		;parity mask	BIT	3,(IX+UCIMAGE)	;enabled?	JR	NZ,SIO2		;go if not	SET	0,A		;set ODD	BIT	7,(IX+UCIMAGE)	;odd?	JR	Z,SIO2		;go if yes	SET	1,A		;set EVENSIO2	SET	2,A		;set 1 stop bit	BIT	4,(IX+UCIMAGE)	;1/2?	JR	Z,$+4		;go if one	SET	3,A		;set 2 stop bits	LD	(IY+5),A	;update table;;	send compiled init data to SIO;	LD	HL,ITABLE	;get init tableRX17	EQU	$-2	CALL	SNDDAT		;send data to chipRX18	EQU	$-2	POP	IY		;restore	XOR	A		;set no error	RET	ENDIF;;;	init wake up feature;	IF	@MOD4CTL4	PUSH	IY		; Xfer pointer to DE	POP	DE	LD	A,D		; Test if set or reset	OR	E	LD	A,0C9H		; Init disable reset	LD	HL,(WAKEADR+1)	; Get old valueRX06	EQU	$-2	JR	Z,SETWAK	; Jump if disable	LD	A,0C3H		; Make enableSETWAK	LD	(WAKEADR),A	; Load the opcodeRX07	EQU	$-2	LD	(WAKEADR+1),DE	; Then the addressRX08	EQU	$-2	PUSH	HL		; Transfer pointer to IY	POP	IY	RET	ENDIF;	IF	@MOD2CTL4	PUSH	IY		;Transfer pointer to HL	POP	HL	LD	A,H		;Test if set or reset	OR	L	LD	A,0C9H		;Init disable wakeup	EX	DE,HL		;Switch new value to DE	LD	HL,(WAKEADR+1)	;  & p/u old in HLRX19	EQU	$-2	JR	Z,SETWAK	LD	A,0C3HSETWAK	LD	(WAKEADR),ARX20	EQU	$-2	LD	(WAKEADR+1),DERX21	EQU	$-2	PUSH	HL		;Transfer pointer to IY	POP	IY	RET	ENDIF;;	Check if ready to send;	IF	@MOD4CANISND	IN	A,(UARTST)	; Look at TX empty bit	CPL			; Flip it	AND	40H		; Mask out all else	IN	A,(MODSTAT)	; Get modem status reg	RET	NZ		; Return if can't send	LD	B,A		; Save modem status	XOR	(IX+MSMASK)	; Mask for which to flip	RRA			; Move into bits 0-3	RRA	RRA	RRA	AND	(IX+MSMASK)	; Mask for which to check	AND	0FH		; Mask off garbage	LD	A,B		; Get reg back	RET			; Ret with Z or NZ	ENDIF;	IF	@MOD2CANISND	LD	C,(IX+BPORT)	;get SIO base port	LD	A,10H		;reset	OUT	(C),A		;reset ext	IN	A,(C)		;RR0 status	CPL			;reverse status	ADD	A,A		;move bits 3/5 to 5/7	ADD	A,A	AND	10110000B	;keep DCD/CTS only	BIT	4,A		;TX buffer empty?	RET	NZ		;go if not	LD	C,A		;save status	XOR	(IX+MSMASK)	;mask for flip	RRA			;align to low	RRA	RRA	RRA	AND	(IX+MSMASK)	;mask for which to check	AND	0FH		;keep low 4 only	LD	A,C		;get back original status	RET			;done	ENDIF;;	Send a character;	IF	@MOD4SEND	LD	A,(IX+UCIMAGE)	; Get UART ctl reg	OUT	(UARTCTL),A	; Put it (clears BREAK)SWAIT	CALL	CANISND		; PollRX09	EQU	$-2	JR	NZ,SWAIT	;   until ready	LD	A,C		; Get byte to send	OUT	(DATAREG),A	; Send it with Z-flag	RET			;   unchanged for return	ENDIF;	IF	@MOD2SEND	PUSH	BC		;save char	LD	A,C		;get char	AND	(IX+WORD)	;strip bits	LD	B,A		;save itSNDWT	CALL	CANISND		;PollRX22	EQU	$-2	JR	NZ,SNDWT	; until ready	CALL	RESBRK		;reset breakRX25	EQU	$-2	LD	C,(IX+BPORT)	;get base port	DEC	C		;point to data port	DEC	C	OUT	(C),B		;send data byte	POP	BC		;restore	LD	A,C		;restore char	CP	A		;set Z for OK	RET			;  unchanged for return	ENDIF;;	Receive character - get from buffer if available;	IF	@MOD4RECV1	CALL	CKINP		; Chk if avail from portRX10	EQU	$-2	RET	NZ		; Back if noneRECV	SLA	(IX+CLFLG)	; Check if avail from buf	JR	NC,RECV1	; Go if none avail	LD	A,(IX+CLBUF)	; Get the char	CP	A		; Set Z flag & exit	RET	ENDIF;	IF	@MOD2RECV	BIT	7,(IX+CLFLG)	;char avail?	JR	NZ,HRECV	;have a char, go!	OR	-1		;set NZ	CPL			;but return 0	RET			;return NO charHRECV	LD	A,(IX+CLBUF)	;Get the char	RES	7,(IX+CLFLG)	;set char fetched	CP	A		;Set Z-flag & exit	RET	ENDIF;;	Break request;	IF	@MOD4CTL1	LD	A,(IX+UCIMAGE)	; Pick up UART ctl image	RES	2,A		; Show BREAK bit	OUT	(UARTCTL),A	RET			; With Z-flag	ENDIF;	IF	@MOD2CTL1	LD	C,(IX+BPORT)	;get base port	LD	A,5		;R5	DI			;disable for send	OUT	(C),A		;select register	LD	A,(IX+R5MASK)	;get mask	OR	10H		;set break bit	OUT	(C),A		;send break	EI	SET	6,(IX+CLFLG)	;show break sent	RET			;With Z-flag	ENDIF;	IF	@MOD2;;	reset break;RESBRK	BIT	6,(IX+CLFLG)	;break send prior?	RET	Z		;nope, go!;	LD	C,(IX+BPORT)	;get base port	LD	A,5		;R5	DI			;disable for select	OUT	(C),A		;select R5	LD	A,(IX+R5MASK)	;get mask	OUT	(C),A		;terminate break	EI			;done	RES	6,(IX+CLFLG)	;reset break cleared	RET			;return	ENDIF;;	Data received interrupt handler;	IF	@MOD4RECVINT	LD	IX,CLDATA$	; Base of data areaRX13	EQU	$-2	CALL	CKINP		; See if available from portRX12	EQU	$-2	LD	A,BWAKEADR	RET			; Wakeup if enabled	ENDIF;	IF	@MOD2RECVINT	LD	IX,CLDATA$RX23	EQU	$-2	LD	C,(IX+BPORT)	;get base port	IN	B,(C)		;read R0	LD	A,10H		;channel reset	OUT	(C),A		;reset	BIT	7,B		;break here?	JR	Z,RECVI1	;go if not	BIT	5,(IX+CLFLG)	;was break sent?	JR	NZ,RECVI2	;go if yes	SET	5,(IX+CLFLG)	;else show as sent	LD	A,(IX+LOGBRK)	;convert for break detect	JR	RECVI3		;else show breakRECVI1	RES	5,(IX+CLFLG)	;terminate break bitRECVI2	BIT	0,B		;RX char available?	RET	Z		;nope, go!	DEC	C		;point to data port	DEC	C	IN	A,(C)		;fetch char	AND	(IX+WORD)	;strip bitsRECVI3	LD	B,A		;pass to B	CALL	CKINP		;check inputRX24	EQU	$-2WAKEADR	RET			;Wakeup if enabled	ENDIF;	DW	0		; Space for address;;	Routine to check on a received character;CKINP	IF	@MOD4	IN	A,(UARTST)	; Check if actually RX	LD	B,A		; Save status	CPL			; Mask Data Received bit	AND	80H	LD	A,00H		; Set "No error"	RET	NZ		; Return if none;	IN	A,(DATAREG)	; Get character	ENDIF	LD	C,A		; Save it in C;;	Break, Pause and Enter handler routine;	LD	HL,$-$		; KFLAG$KFLAG	EQU	$-2	CP	CR		; ENTER char received?	JR	NZ,PAWSCK	; Go if not	SET	2,(HL)		; Set ENTER bit	JR	RECVEX;PAWSCK	CP	60H		; Pause char received?	JR	NZ,BRKCHK	; Go if not	SET	1,(HL)		; Set pause bit	JR	RECVEX;BRKCHK	LD	A,(IX+LOGBRK)	; Break char received?	OR	A		; Check if LOGBRK=0	JR	Z,RECVEX	; No valid break if =0	CP	C		; Check if a valid break	IF	@MOD4	JR	Z,BRKRECD	; Go if so	IN	A,(UARTST)	; Check for framing error	AND	10H	JR	Z,RECVEX	; Quit if none	ENDIF	IF	@MOD2	JR	NZ,RECVEX	;go if not	ENDIF;;	A break was received, check system's BREAK disable;BRKRECD	LD	A,($-$)		; Check if break keySFLAG	EQU	$-2	AND	10H		;   is disabled	LD	A,00H		; Ret NZ & A=0 if	RET	NZ		;   the BREAK is disabled	SET	0,(HL)		; Else set break bit	LD	C,80H		;   & reset BREAK codeRECVEX	LD	(IX+CLBUF),C	; Put char in 1 char buf	IF	@MOD4	LD	(IX+CLFLG),80H	; Set char available	ENDIF	IF	@MOD2	SET	7,(IX+CLFLG)	;show char avail	ENDIF	XOR	A		; Set Z flag	RET;	IF	@MOD2;;	issue init data to SIO/CTC chips;SNDDAT	LD	E,(HL)		;get table count	INC	HL		;point to data;SNDDAT1	LD	B,(HL)		;get data count	INC	HL		;bump	LD	C,(HL)		;get port#	INC	C		;check if nil	DEC	C	RET	Z		;yes, ignore CTC2!	INC	HL		;else point to config dat	OTIR			;send to port	DEC	E		;less table count	JR	NZ,SNDDAT1	;go for count	RET			;else done!;;	init data for SIO ports;ITABLE	DB	3		;# tables;	DB	11		;# entries this table	DB	$SIOA		;SIO base port address	DB	018H		;channel reset	DB	004H		;R4	DB	044H		;X16, stop=1	DB	003H		;R3	DB	0E1H		;word=8, RX	DB	005H		;R5	DB	0EAH		;DTR,W=8,TX,RTS	DB	002H		;R2	DB	0		;offset interrupt	DB	1+10H		;reset int, R1	DB	01DH		;int on all RX chars;;	CTC #1 setup;	DB	3		;# entries this table	DB	$CTC0		;CTC0 base port address	DB	007H		;count, reset	DB	034H		;default 300 baud	DB	0		;offset interrupt vector;;	CTC #2 setup;	DB	2		;# entries	DB	$CTC1		;CTC1 base port	DB	007H		;count, reset	DB	034H		;default 300 baud;;	baud rate lookup table;BAUDTBL	DW	0FE07H		;50	DW	0D007H		;75	DW	08E07H		;110	DW	07407H		;135	DW	06807H		;150	DW	03407H		;300	DW	01A07H		;600	DW	00D07H		;1200	DW	04547H		;1800	DW	03E47H		;2000	DW	03447H		;2400	DW	02347H		;3600	DW	01A47H		;4800	DW	01147H		;7200	DW	00D47H		;9600	DW	00647H		;19200	ENDIF;;CLEND	EQU	$;	IF	@MOD4RELTAB	DW	RX01,RX02,RX03,RX04	DW	RX05,RX06,RX07,RX08	DW	RX09,RX10,RX11,RX12	DW	RX13,RX14;TABLEN	EQU	$-RELTAB/2	ENDIF;	END	BEGIN