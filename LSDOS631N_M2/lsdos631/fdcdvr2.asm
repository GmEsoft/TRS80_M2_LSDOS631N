;****************************************************************;* Filename: FDCDVR2/ASM					*;* Rev Date: 30 Nov 97						*;* Revision: 6.3.1						*;****************************************************************;* TRS-80 Model II Floppy Disk Driver routines			*;****************************************************************;	SUBTTL	'<Floppy Disk Driver>';;	HL -> Buffer Address;	D  -> Track desired;	E  -> Sector desired;	C  -> Drive desired;	B  -> Disk primitive command;;;;	Disk Driver Entry Point;FDCDVR	JR	FDCBGN		;Driver Start	DW	BUCKET	DB	03H	DB	'$FD';;	Automatic density recognition and retry density switch;SWDEN	LD	A,(IY+3)	;Flip the density bit,	XOR	40H		;  Bit 6, (IY+3)	LD	(IY+3),A	PUSH	BC	LD	BC,270FH	;Set alloc to SDEN	BIT	6,A		;Test SDEN/DDEN	JR	Z,SDEN		;Do SDEN if it was DDEN	LD	BC,491DH	;  else set alloc to DDENSDEN	LD	(IY+7),C	LD	(IY+8),B	POP	BC	LD	A,B		;Check counter for 2	CP	03H		;  tries after this one	JR	Z,RESTOR	;If so try a restore	XOR	A	RET;;	Execute WRITE using DMA;WROUT	LD	($DMA2HL),HL	;Sector write buffer	LD	HL,$DMA2	JR	SENDDMA;;	Verify routine;VERFIN	LD	HL,BUCKET	;Byte bucket address for verify	LD	A,20H		;0010 0000: Grp 2 - Port B Memory, address fixed (byte bucket)	JR	SENDMA1		;Do read/verify;;	Read routine;RDIN	LD	A,10H		;0001 0000: Grp 2 - Port B Memory, address incrementing;SENDMA1	LD	($DMA1HL),HL	;Sector read buffer address	LD	($DMA1A),A	;Sector read increment mode (increment or fixed)	LD	HL,$DMA1	;DMA commands for FDC data read;SENDDMA	CALL	TSTBSY	RET	NZ	LD	A,C	LD	BC,0FF8H	; Send 15 bytes to DMA Controller	OTIR	LD	HL,BSYFLG$	; busy flag for INT	LD	C,A	CALL	SEND$D0	BIT	5,A	LD	A,C	JR	NZ,L0EF6	OR	04HL0EF6	BIT	4,(IY+3)	JR	Z,L0EFE	OR	08HL0EFE	SET	7,(HL)		; Set busy flag for INT	OUT	(0E4H),A	; Send FDC Command	DI			; DMA operation start: disable interrupts	LD	A,87H		; 1000 0111: Grp 6 - Enable DMA	OUT	(0F8H),A	; Send DMA Command	CALL	DLY000E		; Mini delayL0F0A	IN	A,(0E4H)	; Get FDC Status	AND	81H			DEC	A	JR	Z,L0F0A		; loop until not busy	LD	A,83H		; 1000 0011: Grp 6 - Disable DMA	OUT	(0F8H),A	; Send DMA Command	EI			; DMA operation end: re-enable interrupts	RES	7,(HL)		; Reset busy flag for INT	RET;;	Driver Start;FDCBGN	LD	A,B		;pickup primitive request	AND	A		;NOP?	RET	Z		;Quit if so	CP	07H	JP	Z,TSTBSY	;Jump on TSTBSY request	JP	NC,IORQST	;Jump on I/O request	CP	06H	JP	Z,SEEKTRK	;Jump on track seek	DEC	A	JR	Z,SELECT	;Jump on drive select	CP	04H	JR	NZ,RESTOR	;Jump on restore request	LD	B,58H		;FDC step in command	CALL	FDCCMD		;Do FDC command	RET	NZ	INC	(IY+5)		;Bump current cylinder	XOR	A	RET;;	Restore routine;RESTOR	LD	B,09H		;FDC restore command	CALL	FDCCMD		;Do FDC command	RET	NZ	CALL	SEND$D0	CPL	ADD	A,A	AND	08H	RET	NZ	LD	(IY+5),00H	;Set track to 0	RET;;	Drive select;SELECT	CALL	TSTBSY	CALL	SEND$D0	PUSH	AF	PUSH	BC	LD	A,(IY+4)	AND	0FH	LD	C,A	LD	A,(IY+3)	ADD	A,A	OR	7FH	XOR	C	POP	BC	BIT	4,(IY+3)	JR	Z,L0F6C	RES	6,AL0F6C	OUT	(0EFH),A	; DRVSLT* Select drive	LD	(PDRV$),A	CALL	SELDRV	POP	AF	BIT	7,A	RET	Z	BIT	2,(IY+3)	CALL	Z,DLY1S		; 1s delay	CALL	SEND$D0	BIT	7,A	RET	Z	LD	A,08H	RET;;	1s delay;DLY1S	PUSH	BC	LD	BC,0000H$DLYBC	CALL	PAUSE@	POP	BC	XOR	A	RET;;	50ms delay;DLY50MS	PUSH	BC	LD	BC,1388H	JR	$DLYBC;;	Select drive and get status;SELDRV	LD	A,(PDRV$)	OUT	(0EFH),A	; DRVSLT* Select drive				; b7: 0=FM - 1=MFM				; b6: 0=Side 1 - 1=Side 0				; b5: unused				; b4: unused				; b3: DRV3SEL 0=SEL - 1=NOTSEL				; b2: DRV2SEL 0=SEL - 1=NOTSEL				; b1: DRV1SEL 0=SEL - 1=NOTSEL				; b0: DRV0SEL 0=SEL - 1=NOTSEL	LD	A,5AH		; Init spin timer	LD	(@SPINTM),A	;	IN	A,(0E4H)	; Get FDC Status	RET;;	Reselect drive while controller is busy;TSTBSY	IN	A,(0E4H)	; Get FDC StatusL0FA7	BIT	0,A	RET	Z	CALL	SELDRV	BIT	7,A	JR	Z,L0FA7	LD	A,08H	RET;;	Routine to seek a track;SEEKTRK	LD	E,00H;;	Seek track/set sector	;TRKSECT	LD	A,(PDRV$)	AND	0FH	LD	(L0FFC),A	CALL	SELECT	LD	A,(IY+5)	;p/u current cylinder	OUT	(0E5H),A	;  & set FDC to current	LD	A,(IY+7)	;p/u alloc data	AND	1FH		;Get highest # sector	SUB	E		;Form req sector minus	CPL			;  max, setting CY flag if	RES	4,(IY+3)	;  init side select to 0	JR	NC,SETSECT	;Go if sector on side 0	BIT	5,(IY+4)	;If not 2-sided media	JR	Z,FRCSID0	;  don't set side 1	SET	4,(IY+3)	;Set side 1	DB	1EH		;Ignore next with LD E,7BHSETSECT	LD	A,E		;Restore unaltered sector #FRCSID0	OUT	(0E6H),A	;Set sector	LD	A,D	OUT	(0E7H),A	;Set desired track	CP	(IY+5)		; If at desired track	LD	B,18H		;  use seek, else use	JR	Z,L0FF0		;  seek with verify	LD	(IY+5),D	; Update current cylinder	SET	2,B		; Seek with verify command (1CH)L0FF0	CALL	FDCCMD		; Do FDC command	RET	NZ	LD	A,(IY+4)	AND	0FH	XOR	0FH	SUB	00HL0FFC	EQU	$-1	RET	Z	JR	DLY50MS		; 50 ms delay;;	Do FDC command;FDCCMD	CALL	SELECT	RET	NZ	CALL	SEND$D0	PUSH	AF	LD	A,(IY+3)	AND	03H	OR	B	CALL	SENDCMD	POP	AF	BIT	5,A	CALL	Z,DLY50MS	; 50 ms delay	CALL	TSTBSY	AND	98H	RET	Z	LD	A,08H	RET;;	Send command $D0 and get status;SEND$D0	LD	A,0D0H	CALL	SENDCMD	IN	A,(0E4H)	; Get FDC Status	RET;;	Send FDC command;SENDCMD	OUT	(0E4H),A	; Send FDC Command;;	Do mini delay after command;DLY000E	LD	A,0EHL102C	DEC	A	JR	NZ,L102CFDCRET	RET;;	I/O request handler;IORQST	BIT	2,A		; Write command?	LD	BC,(007AH)	; Pick up retry count	LD	C,82H		;FDC Read Sector command	JR	NZ,WRCMD	;Go if write command	CP	0AH		;Verify sector?	JR	Z,VERFY	CALL	GRABNDO		;Grab next code & insert	DB	08H		; Error code start	DW	RDIN		; Read entry point;;	Do sector verify routine;VERFY	CALL	GRABNDO		;Stuff I/O direction	DB	08H		; Error code start	DW	VERFIN		; Verify entry point;;	Check software R/O and do sector write routine;WRCMD	BIT	7,(IY+3)	;Software write prot?	JR	Z,WRCMD1	;Bypass if not	LD	A,0FH		;Else set WP error	RET;;	Do sector write/format routine;WRCMD1	LD	C,0A2H		;FDC Write Sector command	CP	0EH		;Write DIR sector?	JR	C,DOWRIT	LD	C,0A3H		;Change DAM if directory	JR	Z,DOWRIT	LD	C,0F0H		;  else write track;;	Execute write or verify;DOWRIT	CALL	GRABNDO		;Switch code	DB	10H		; Error code start	DW	WROUT		; Write entry point;;	Routine stuffs error start byte & I/O vector;GRABNDO	EX	(SP),HL		;save HL and get RET address from the stack	LD	A,(HL)		;p/u & stuff error code	INC	HL		;  start byte	LD	(L10A7),A	CALL	GTHL@HL		;Set up data transfer direction vector	LD	(DISKIO$),HL	;Stuff CALL vector	POP	HL		;Restore buffer addrRETRY	PUSH	BC		;Save retry & FDC command	PUSH	DE		;Save track/sector	PUSH	HL		;Save buffer addr	BIT	4,C		;Test for track command	JR	NZ,L107E	CALL	TRKSECT		;Seek if not track write	JR	NZ,L1081L107E	CALL	0000H		;Call I/O routineDISKIO$	EQU	$-2L1081	CALL	SELDRV	AND	0FDH	POP	HL		;Recover buffer addr	POP	DE		;Recover track/sector	POP	BC		;Recover retry count & command	RET	Z		;Return if no error	BIT	2,A		;Lost data?	JR	NZ,L10A0	;Don't count this retry	PUSH	AF	AND	98H		;Record not found or CRC?	JP	M,DISKDUN	;No retries if otherwise	JR	Z,DISKDUN	BIT	4,A		;Record not found?	PUSH	BC		;If so, switch	CALL	NZ,SWDEN	;  density or restore	POP	BC	JR	NZ,L10BA	POP	AFL10A0	DJNZ	RETRY		;Count down retry	DB	6		;Ignore next with LD B,nDISKDUN	POP	AF		;Adjust RET code	PUSH	BC	LD	B,A	LD	A,00H		;Start with R=1-8, W=9-16L10A7	EQU	$-1ERRTRAN	RLC	B	JR	C,L10B1	DEC	A	JR	NZ,ERRTRAN	LD	A,08HL10B1	CP	10H	JR	NZ,L10B7	LD	A,08HL10B7	OR	A	POP	BC	RETL10BA	EX	(SP),HL	POP	HL	RET;;	DMA Commands 1 - Read FDC, write memory (read/verify);$DMA1	DB	0C3H		;1100 0011: Grp 6 - Reset command	DB	8BH		;1000 1011: Grp 6 - Reinit status byte	DB	69H		;0110 1001: Grp 0 - Set port addr/length, transfer, B->A	DB	0E7H		;Port A starting addr low byte = Port 0E7H = FDC Data Reg	DB	00H		;Block len (0100H) low byte	DB	01H		;Block len (0100H) high byte	DB	3CH		;0011 1100: Grp 1 - Port A I/O, address fixed$DMA1A	DB	10H		;0001 0000: Grp 2 - Port B Memory, address increments;	or 20H for VERIFY	;0010 0000: Grp 2 - Port B Memory, address fixed (byte bucket)	DB	8DH		;1000 1101: Grp 4 - Port B Byte Mode + starting address$DMA1HL	DW	0		;Port B Starting address	DB	8AH		;1000 1010: Grp 5 - Rdy act hi, CE* only, stop @end-of-block	DB	0CFH		;1010 1111: Grp 6 - Load command	DB	05H		;0000 0101: Grp 0 - A->B	DB	0CFH		;1010 1111: Grp 6 - Load command;;	DMA Commands 2 - Read memory, write FDC (write/format);$DMA2	DB	0C3H		;1100 0011: Grp 6 - Reset command	DB	8BH		;1000 1011: Grp 6 - Reinit status byte	DB	79H		;0111 1001: Grp 0 - Set port addr/length, transfer, B->A$DMA2HL	DW	0		;Port A Starting Address	DB	0B0H		;Port A block length (29B0H) low byte	DB	29H		;Port A block length (29B0H) high byte	DB	14H		;0001 0100: Grp 1 - Port A Memory, address increments	DB	28H		;0010 1000: Grp 2 - Port B I/O, address fixed	DB	85H		;1000 0101: Grp 4 - Port B Byte Mode + starting addr LSB	DB	0E7H		;Port 0E7H = FDC Data Reg	DB	8AH		;1000 1010: Grp 5 - Rdy act hi, CE* only, stop @end-of-block	DB	0CFH		;1010 1111: Grp 6 - Load command	DB	05H		;0000 0101: Grp 0 - A->B	DB	0CFH		;1010 1111: Grp 6 - Load command;@SPINTM	DB	5AH		;Drive Spin off timer (used by TASKER);BUCKET	DB	00H		;Byte bucket for VERIFY	END