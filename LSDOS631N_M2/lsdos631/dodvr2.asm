;****************************************************************;* Filename: DODVR2/ASM						*;* Rev Date: 30 Nov 97						*;* Revision: 6.3.1						*;****************************************************************;* TRS-80 Model II Video Driver routines			*;****************************************************************;	SUBTTL	'<Video Driver>'*MODCRTBGN$	EQU	0F800H		;Address of screen start;;	Driver Entry Point;@DODVR	EQU	$DODVR	JR	DOBGN		;Driver Code	DW	DOEND	DB	03H	DB	'$DO'	DW	DODCB$,0000HDODATA$	DB	00HL0B83	DW	CRTBGN$L0B85	DB	20H@CRSCHAR	DB	47H	;80/40 chars per lineLLEN$	DW	0050H	;CRT buffer past-end (for modes 80/40)CRTEND1	DW	0FF80HL0B8B	DW	L0730	;Entry from SVC 15, @VDCTL@VDCTL	JP	@_VDCTL		;Video control SVC processor	;Driver CodeDOBGN	LD	IX,DODATA$	CALL	ENADIS_DO_RAM	LD	DE,(L0B83)	JR	C,GET_@		;'GET' request	PUSH	BC	LD	A,C	BIT	4,(IX+0)	JR	NZ,L0BAE	OR	A	JP	Z,TGGLCTL	;Toggle CTL bit - quote next char	CP	20H		; ' '	JP	C,DO_CONTROL	;Routines to parse control functionsL0BAE	CP	0C0H	JR	C,DO_NORM	;Display the char	BIT	3,(IX+0)	JR	Z,DO_TABS	;Perform a tab expansion (C0-FF)	;Display the charDO_NORM	CALL	DO_DSPCHAR	;Display character <C> at current cursor position	RES	4,(IX+0)	;return into DO DriverDO_RET	POP	BCDO_RET1	LD	(L0B83),DE	LD	A,(DE)	LD	(L0B85),A	PUSH	HL	LD	HL,BSYFLG$	;TODO: busy flag for int ?	SET	6,(HL)	LD	A,0EH	OUT	(0FCH),A	LD	A,D	AND	07H	OUT	(0FDH),A	LD	A,0FH	OUT	(0FCH),A	LD	A,E	OUT	(0FDH),A	RES	6,(HL)	POP	HL	CP	A	LD	A,C	RET	;'GET' requestGET_@	LD	A,(DE)	LD	C,A	CP	A	RET	;Routine to stuff the video cursor RAM address@VDCTL3	PUSH	HL	CALL	ROWCOL_2_ADDR	;Routine to calculate cursor position from row,col	JR	NZ,L0BF1	CALL	DO_RET1L0BF1	POP	HL	RET	;Perform a tab expansion (C0-FF)DO_TABS	SUB	0C0H	JR	Z,DO_RET	;return into DO Driver	LD	B,AL0BF8	LD	C,20H		; ' '	CALL	DO_DSPCHAR	;Display character <C> at current cursor positionL0BFC	EQU	$-1	DJNZ	L0BF8	JR	DO_RET		;return into DO Driver	;Routine to move the cursor to begin of line (29)CRSBOL	CALL	GETBOL		;Get address of begin of lineL0C03	EQU	$-1	EX	DE,HL	RET	;Get address of begin of lineGETBOL	PUSH	DE	LD	HL,CRTBGN$	LD	BC,(LLEN$)	;80/40 chars per lineL0C0E	PUSH	HL	ADD	HL,BC	SCF	SBC	HL,DE	POP	HL	JR	NC,L0C19	ADD	HL,BC	JR	L0C0EL0C19	POP	DE	XOR	A	RET	;Routine to turn off the cursor (15)CRSOFF	LD	A,27H		; '''	JR	L0C26	;Routine to turn on the cursor (14)CRSON@	LD	A,(@CRSCHAR)L0C23	LD	(@CRSCHAR),AL0C26	PUSH	BC	PUSH	HL	LD	HL,VFLAG$	SET	6,(HL)		; Inhibit blinking (user)	CP	27H		; '''	JR	Z,L0C33	RES	6,(HL)		; Enable blinking (user)L0C33	LD	HL,BSYFLG$	;TODO: busy flag for int ?	SET	6,(HL)	LD	BC,0AFCH	OUT	(C),B	INC	C	OUT	(C),A	LD	BC,0BFCH	OUT	(C),B	INC	C	IF	@BLD631M	; Larger default cursor	LD	A,08H		;   for better visibility	ELSE	LD	A,07H		; Old default cursor	ENDIF	OUT	(C),A	RES	6,(HL)	POP	HL	POP	BC	XOR	A	RET	;Set to 40 char/line mode (23)SET40	CALL	PGMWIDE		;Program CRT for wide chars	CALL	L0C5C	JP	CLREOF		;Clear to the end of the frame	;Routine moves cursor to start of video page (28)CRSHOME	CALL	PGMNORM		;Program CRT for normal charsL0C5C	CALL	L0CD3	CALL	DO_INVERT_DIS	;Routine to disable reverse video	LD	DE,CRTBGN$	RET	;Get addr of 1st unprotected lineSCLPROT	LD	A,(IX+0)	AND	07H	LD	DE,CRTBGN$L0C6E	RET	Z	LD	HL,(LLEN$)	;80/40 chars per line	ADD	HL,DE	EX	DE,HL	DEC	A	JR	L0C6E	;Routine to backspace and erase cursor (8)BACKSPA	CALL	CRSBKSP		;Routine to backspace the cursor (24)	LD	C,20H		; ' '	JP	PUT_@		;put a character	;Routine to backspace the cursor (24)CRSBKSP	DEC	DE	JR	L0C8C	;Routine to move the cursor up one line (27)CRSUP	CALL	GETBOL		;Get address of begin of line	LD	DE,(LLEN$)	;80/40 chars per line	SBC	HL,DE	EX	DE,HLL0C8C	LD	HL,CRTBGN$	PUSH	HL	SCF	SBC	HL,DE	POP	HL	RET	C	EX	DE,HL	RET	;Routine to move the cursor down one line (26)CRSDOWN	LD	HL,(LLEN$)	;80/40 chars per line	ADD	HL,DE	EX	DE,HL	JP	L0D3E	;Program CRT for wide charsPGMWIDE	LD	E,10H	LD	HL,$PGWIDE	;CRT Data for wide chars (4 bytes CRT/4 bytes line len)	JR	L0CAB	;Program CRT for normal charsPGMNORM	LD	E,00H	LD	HL,$PGNORM	;CRT Data for normal chars (4 bytes CRT/4 bytes line len)L0CAB	LD	BC,04FDH	;4 bytes to OUTI to port $FD	XOR	AL0CAF	OUT	(0FCH),A	INC	A	OUTI	JR	NZ,L0CAF	PUSH	DE	LD	DE,LLEN$	;80/40 chars per line	LD	C,04H	LDIR	CALL	SCLPROT		;Get addr of 1st unprotected line	LD	HL,(CRTEND1)	;CRT buffer past-end (for modes 80/40)	OR	A	SBC	HL,DE	LD	DE,(LLEN$)	;80/40 chars per line	OR	A	SBC	HL,DE	LD	(L0B8B),HL	POP	DE	RETL0CD3	LD	HL,(OPREG_SV_PTR)	DEC	HL	LD	A,(HL)	AND	0EFH	OR	E	LD	(HL),A	RET	;Routines to parse control functionsDO_CONTROL	LD	HL,DO_RET	;return into DO Driver	PUSH	HL	LD	HL,LKUPTB2	;Lookup table of ctrl chars	CALL	LOOKUP_		;lookup byte in vector table	RET	NZ	JP	(HL)	;Lookup table of ctrl charsLKUPTB2	DB	08H	DW	BACKSPA		;Routine to backspace and erase cursor (8)	DB	0AH	DW	LINFEED		;Routine to move down one line (10,13)	DB	0DH	DW	LINFEED		;Routine to move down one line (10,13)	DB	0EH	DW	CRSON@		;Routine to turn on the cursor (14)	DB	0FH	DW	CRSOFF		;Routine to turn off the cursor (15)	DB	10H	DW	DO_INVERT_ENA		;Routine to enable reverse video	DB	11H	DW	DO_INVERT_DIS		;Routine to disable reverse video	DB	15H	DW	TGGLTAB		;Toggle tabs & alternate character set	DB	17H	DW	SET40		;Set to 40 char/line mode (23)	DB	18H	DW	CRSBKSP		;Routine to backspace the cursor (24)	DB	19H	DW	CRSFRWD		;Routine to perform cursor forward (25)	DB	1AH	DW	CRSDOWN		;Routine to move the cursor down one line (26)	DB	1BH	DW	CRSUP		;Routine to move the cursor up one line (27)	DB	1CH	DW	CRSHOME		;Routine moves cursor to start of video page (28)	DB	1DH	DW	CRSBOL		;Routine to move the cursor to begin of line (29)	DB	1EH	DW	CLREOL		;Clear to the end of the line	DB	1FH	DW	CLREOF		;Clear to the end of the frame	DB	0FFH	;Routine to enable reverse videoDO_INVERT_ENA	LD	A,80H	DB	2EH	;Routine to disable reverse videoDO_INVERT_DIS	XOR	A	LD	(INVVIDEO),A	;	RRCA	RRCA	RRCA	RRCA	LD	(OPREG$),A	RET	;Toggle CTL bit - quote next charTGGLCTL	LD	HL,DO_RET	;return into DO Driver	PUSH	HL	LD	A,10H	DB	21H	;Toggle tabs & alternate character setTGGLTAB	LD	A,08H	XOR	(IX+0)	JR	SETMASK		;Set DODATA$ flags	;Display character <C> at current cursor positionDO_DSPCHAR	CALL	PUT_@		;put a character	;Routine to perform cursor forward (25)CRSFRWD	INC	DEL0D3E	LD	HL,(CRTEND1)	;CRT buffer past-end (for modes 80/40)	SCF	SBC	HL,DE	RET	NC	CALL	SCLPROT		;Get addr of 1st unprotected line	LD	H,D	LD	L,E	PUSH	BC	LD	BC,(LLEN$)	;80/40 chars per line	ADD	HL,BC	LD	BC,(L0B8B)	LDIR	POP	BC	JR	CLREOF		;Clear to the end of the frame	;Set scroll protect value - @VDCTL:7SET_SCROLL	LD	A,C	AND	07H	LD	C,A	LD	A,(DODATA$)	AND	0F8H	OR	C	;Set DODATA$ flagsSETMASK	LD	(DODATA$),A	XOR	A	RET	;Routine to move down one line (10,13)LINFEED	CALL	CRSBOL		;Routine to move the cursor to begin of line (29)	LD	HL,(LLEN$)	;80/40 chars per line	ADD	HL,DE	EX	DE,HL	CALL	L0D3E	;Clear to the end of the lineCLREOL	CALL	GETBOL		;Get address of begin of line	LD	BC,(LLEN$)	;80/40 chars per line	ADD	HL,BC	SBC	HL,DE	JR	L0D85	;Clear to the end of the frameCLREOF	LD	HL,(CRTEND1)	;CRT buffer past-end (for modes 80/40)	OR	A	SBC	HL,DEL0D85	PUSH	DE	PUSH	BC	LD	B,H	LD	C,L	EX	DE,HL	LD	A,(INVVIDEO)	;	OR	20HL0D8F	LD	(HL),A	CPI	JP	PE,L0D8F	POP	BC	POP	DE	RET	;Video control SVC processor@_VDCTL	PUSH	DE	CALL	VDCTL		;Lookup @VDCTL function in table	POP	DE	RET	;Lookup @VDCTL function in tableVDCTL	CALL	ENADIS_DO_RAM	PUSH	HL	LD	HL,LKUPTB3	;Lookup table for @VDCTL functions	LD	A,B	CALL	LOOKUP_		;lookup byte in vector table	EX	(SP),HL	RET	Z	POP	AF	JP	PERR		;SVC parameter error	;Lookup table for @VDCTL functionsLKUPTB3	DB	01H	DW	GET_@_ROWCOL		;Routine to get the character at row,col	DB	02H	DW	PUT_@_ROWCOL		;Routine to put a character at row,col	DB	03H	DW	@VDCTL3		;Routine to stuff the video cursor RAM address	DB	04H	DW	ADDR_2_ROWCOL		;Routine to get row,col of video cursor	DB	05H	DW	VIDMOV1		;Routine to move video RAM - full screen	DB	06H	DW	VIDMOVE		;Routine to move video RAM	DB	07H	DW	SET_SCROLL		;Set scroll protect value - @VDCTL:7	DB	08H	DW	CRSCHR		;Establish cursor character	DB	09H	DW	VIDLIN		;VIDLIN routine function - 9 in register B	DB	0FFH	;VIDLIN routine function - 9 in register BVIDLIN	LD	L,00H	PUSH	DE	CALL	ROWCOL_2_ADDR	;Routine to calculate cursor position from row,col	POP	HL	RET	NZ	INC	C	DEC	C	JR	Z,L0DD8	EX	DE,HLL0DD8	LD	BC,(LLEN$)	;80/40 chars per line	LDIR	XOR	A	RET	;Establish cursor characterCRSCHR	LD	A,(@CRSCHAR)	PUSH	AF	LD	A,C	CALL	L0C23	POP	AF	CP	A	RET	;Routine to move video RAMVIDMOVE	LD	A,H	ADD	A,08H	CP	2CH		; ','	JR	C,PERR		;SVC parameter error	LD	DE,CRTBGN$	EX	DE,HL	JR	L0DFB	;Routine to move video RAM - full screenVIDMOV1	LD	DE,CRTBGN$L0DFB	PUSH	HL	PUSH	HL	LD	HL,(CRTEND1)	;CRT buffer past-end (for modes 80/40)	LD	BC,CRTBGN$	OR	A	SBC	HL,BC	LD	B,H	LD	C,L	POP	HL	LDIR	POP	HL	XOR	A	RET	;Routine to get the character at row,colGET_@_ROWCOL	CALL	ROWCOL_2_ADDR	;Routine to calculate cursor position from row,col	LD	A,(DE)	RET	;Routine to put a character at row,colPUT_@_ROWCOL	CALL	ROWCOL_2_ADDR	;Routine to calculate cursor position from row,col	RET	NZ	;put a characterPUT_@	LD	A,00HINVVIDEO	EQU	$-1	OR	C	LD	(DE),A	CP	A	RET	;Routine to calculate cursor position from row,colROWCOL_2_ADDR	LD	A,(LLEN$)	;80/40 chars per line	DEC	A	CP	L	JR	C,PERR		;SVC parameter error	LD	A,H	CP	18H	JR	NC,PERR		;SVC parameter error	PUSH	HL	PUSH	BC	LD	C,L	LD	B,0F8H	LD	HL,(LLEN$)	;80/40 chars per line	CALL	@MUL16	LD	H,L	LD	L,A	ADD	HL,BC	EX	DE,HL	POP	BC	POP	HL	XOR	A	RET	;SVC parameter errorPERR	LD	A,2BH		; '+'	OR	A	RET	;Routine to get row,col of video cursorADDR_2_ROWCOL	LD	HL,(L0B83)	LD	A,H	AND	07H	LD	H,A	LD	A,(LLEN$)	;80/40 chars per line	CALL	@DIV16	LD	H,L	LD	L,A	XOR	A	RET	;CRT Data for wide chars (4 bytes CRT/4 bytes line len)$PGWIDE	DB	31H,28H,2BH,04H	DW	0028H,0FBC0H	;CRT Data for normal chars (4 bytes CRT/4 bytes line len)$PGNORM	DB	63H,50H,55H,08H	DW	0050H,0FF80HDOEND	EQU	$-1	END