;****************************************************************;* Filename: KIDVR2/ASM						*;* Rev Date: 30 Nov 97						*;* Revision: 6.3.1						*;****************************************************************;* TRS-80 Model II Keyboard Driver routines			*;****************************************************************;	SUBTTL	'<Keyboard Driver>'*MOD;LF	EQU	10CR	EQU	13;KIDVR	JR	KIBGN		;Entry to keyboard driver	DW	KILAST		;Last byte used	DB	03H	DB	'$KI'	DW	KIDCB$		;Pointer to DCB	DW	0000H		;SpareKIDATA$ DB	0		;Last key entered	DB	0		;Repeat time checkRPTINIT EQU	$-KIDATA$	;Not used on Model II	DB	22		;22 * 33.3ms = .733 secsRPTRATE EQU	$-KIDATA$	;Not used on Model II	DB	2		;2 x RTC rateTYPBUF$	DW	TYPBUF		;Typeahead buffer ptr	DB	50H		;buffer size	DB	00H		;GET pointer offset	DB	00H		;PUT pointer offset	DB	00H		;ESC flag (0 if not, $FF if yes);;	Entry to keyboard driver;KIBGN	LD	A,C		;Get the character	PUSH	AF		;Save the flags	CALL	@KITSK		;Hook for KI task	POP	AF;;	Screen print (Esc-??) processing;	CALL	TYPAHD@		;Chain downstream	RET	NZ		;Return if not <ESC>	PUSH	AF		;Save flag state	CP	0BBH	JR	Z,L09C8		;Go if screen print	POP	AF	RET;;	Perform a screen print;L09C8	POP	AF		;Clean the stack@PRTSCR	LD	A,(DFLAG$)	;Check on graphic init	RLCA	LD	A,3EH		;Init for LD A,'.'	JR	NC,L09D3	;Go if not graphic	LD	A,0FEH		;Change to CP NL09D3	LD	(L09F0),A	;Stuff CP or LD instr	LD	HL,KFLAG$	;Reset the break bit	RES	0,(HL)	PUSH	HL		;Save on the stack	LD	HL,0000H	;Init for row,colL09DF	LD	B,01H		;Get a character at the	CALL	@VDCTL		;  row-H, col-L	JR	NZ,L0A10	;Go on error	CP	20H			JR	NC,L09EC	;Convert control codes	ADD	A,40H		;  to cap A-Z andL09EC	CP	80H		;Convert anything from 80h	JR	C,L09F2		;  through FFh to '.'L09F0	LD	A,2EH		;  unless graphic bit setL09F2	CALL	@PRT		;Print the character & loop	JR	NZ,L0A10	INC	L		;Bump col pointer	LD	A,L		;Check for end of line	LD	BC,(LLEN$)		SUB	C			JR	NZ,L09DF	;Loop if not EOL	LD	L,A		;Reset to col 0	DEC	L		;Adj for CR force	EX	(SP),HL		;Get KFLAG$	BIT	0,(HL)		;Exit with A=0 on	EX	(SP),HL		;  entrance of BREAK	JR	NZ,L0A10		INC	H		;Bump row counter	LD	A,H		;Test for end of screen	CP	18H	LD	A,0DH			JR	NZ,L09F2	;Put the CR and loopL0A10	LD	A,0DH		;Close out with CR if	CALL	@PRT		;  BREAK key detected	POP	HL		;Pop the KFLAG	RES	0,(HL)		;  & reset BREAK bit	OR	0FFH	CPL	RET;;	Check the type ahead buffer for any character;TYPAHD@	CALL	ENADIS_DO_RAM	;Bring up video RAM (typeahead buffer)	LD	IX,TYPBUF$	;Point to typeahead data area	JR	C,L0A2D		;Go on @GET	JR	Z,L0A2B		;No PUT to *KI	CP	03H		;CTL 3 function?	JR	Z,L0A40		;Clear buffer if soL0A2B	XOR	A		;Done	RET;;	do @GET;L0A2D	CALL	L08EC		;get pending key offset	JR	NC,L0A43	;jump if no pending key	LD	(IX+4),A	;new key offset	LD	A,(HL)		;get pending key	INC	A		;test for $FF (EOF?)	JR	Z,L0A3C		;jump if $FF	DEC	A		;no $FF	CP	A		;set Z, NC	RET;;	got $FF, return 1C;L0A3C	LD	A,1CH		;return End-Of-File error	OR	A		;set NZ, NC	RET;;	clear buffer;L0A40	CALL	L0B0F;;	clear no char in typeahead flag;L0A43	LD	HL,KFLAG$	RES	7,(HL)		;no char in typeahead	OR	0FFH		;A=$FF, set NZ	CPL			;set CL0A4B	RET;; 	KB int handler (from INTVC1$ vector table);@INTKI	EX	(SP),HL	LD	(L0B3F),HL	;save caller address (for range check)	EX	(SP),HL	PUSH	AF	PUSH	BC	PUSH	DE	PUSH	HL	PUSH	IX	LD	HL,L0A4B	;RET vector	LD	(L0A7B),HL	;put at end of handler	IN	A,(0FCH)	;get keystroke	AND	7FH		;mash high bit (CAPS flag)	LD	C,A		;save	IF	@BLD631M	;===> fix SP in DO RAM bug	LD	($KISVSP),SP	;Save stack pointer	LD	HL,0FFFFH-0F3FCH;Can't exceed F3FCH	ADD	HL,SP		;Check for overflow	JR	NC,$+5		;If not, skip next instr	LD	SP,0360H	;Else keep room at top	ENDIF			;<=== fix SP in DO RAM bug	LD	A,(MODOUT$)	;get MODOUT$ flags	PUSH	AF		;save them	CALL	@MSET7		;bring in $DO memory (typeahead buffer)	LD	A,C		;restore keystroke	CALL	L0A7D		;process it	POP	AF		;restore MODOUT$ flags	CALL	@MODOUT		;Restore port image and the port	IF	@BLD631M	;===> fix SP in DO RAM bug	LD	SP,$-$		;Get the old stack$KISVSP	EQU	$-2	ENDIF			;<=== fix SP in DO RAM bug	POP	IX	POP	HL	POP	DE	POP	BC	POP	AF	CALL	L099E		;EI - RETI	JP	L0A4B		;RET or DEBUGL0A7B	EQU	$-2;;	Process keystroke from interrupt;L0A7D	LD	IX,TYPBUF$	INC	(IX+5)		;Last key was <ESC>?	JR	Z,L0A91		;jump if yes	DEC	(IX+5)		;reset ESC flag ($00)	CP	1BH		;<ESC> ?	JR	NZ,GOTBRK	;jump if not	DEC	(IX+5)		;set ESC flag ($FF)	RET;;	Process ESC sequence;L0A91	CP	1BH		;Ctrl char?	LD	B,A		;save to B for 1C-1F handling	JR	C,L0A9A		;go if yes	CP	20H		;<ESC> or arrows ?	JR	C,L0AFC		;store key as is if yes;	Ctrl char of displayable char (not in range 1B..1F)L0A9A	LD	B,00H		;	OR	A		;<NUL> ?	JR	Z,L0AFC		;store key if yes	DEC	B		;	CP	0DH		;<ENTER> ?	JR	Z,L0AFC		;store key=$FF if yes	LD	B,03H		;<Ctrl-C> ?	CP	B		;store key if yes	JR	Z,L0AFC		;	LD	B,60H		;	CP	20H		;<SPACE> ?	JR	Z,L0AFC		;store key=$60 if yes	CP	09H		;<TAB> ?	JR	Z,L0B0F		;clear typeahead if yes			CALL	@UPPER		;convert keystroke to upper case	OR	80H		;set high bit	LD	B,A		;	JR	L0AFC		;and store key;;	Handle keystroke, check if Break was hit;	On Model 4 this part is in TASKER/ASM;GOTBRK	CP	03H		;Ctrl-C (Break) ?	JR	NZ,L0AE9	;jump if not (translate and store key)	LD	HL,SFLAG$	;get SFLAG$	BIT	4,(HL)		;BREAK key disabled?	RET	NZ		;return if yes	LD	HL,KFLAG$	;set BREAK latch	SET	0,(HL)		;	LD	HL,@DBGHK	;Debug hook (RET or NOP)	LD	A,(HL)		;get hook flag	LD	(HL),0C9H	;disable hook	INC	HL		;	OR	A		;hook active (NOP)?	JR	Z,L0B36		;jump if not	LD	HL,0000H	;Break hook vectorBRKVEC$	EQU	$-2	LD	A,H		;is null?	OR	L		;	JR	NZ,L0B1F	;jump if not	LD	HL,DFLAG$	;get DFLAG$	BIT	1,(HL)		;Typeahead active?	JR	Z,L0AE7		;jump if not	CALL	L08EC		;get pending key offset	JR	C,L0B0F		;clear typeahead if key pendingL0AE7	LD	A,80H		;<Break>;;	Translate and store key;L0AE9	CALL	LKUPARW		;Translate arrow keys	LD	B,A		;save key value	OR	A		;is zero?	LD	HL,KFLAG$	;	JR	NZ,L0AF6	;skip if not	SET	1,(HL)		;set PAUSE latch	RET			;and returnL0AF6	CP	0DH		;<ENTER> ?	JR	NZ,L0AFC	;skip if not	SET	2,(HL)		;set ENTER latch;;	Store key in B into typeahead buffer;L0AFC	LD	HL,DFLAG$	;get DFLAG$	BIT	1,(HL)		;check if typeahead enabledL0B00	EQU	$-1	CALL	Z,L0B0F		;if not, clear typeaheadL0B04	CALL	L0908		;bump PUT buffer offset	RET	NC		;return if buffer full	LD	(HL),B		;store key in buffer	LD	HL,KFLAG$	;set char in typeahead flag	SET	7,(HL)	RET;;	Clear typeahead;L0B0F	XOR	A	LD	(IX+3),A	LD	(IX+4),A	LD	(IX+5),A	LD	HL,KFLAG$	;clear char in typeahead flag	RES	7,(HL)	RET;;	Handle Break hook vector;L0B1F	PUSH	HL		; save hook vector	CALL	L0B0F		; Clear typeahead	LD	B,80H		;	CALL	L0B04		; Put <Break> in buffer	POP	HL		; restore vector	LD	A,(L0B40)	; Check if int caller is below $2400 (DOS)	CP	24H		;	RET	C		; Return if yes	PUSH	HL		;	LD	HL,040FH	; point to $HIGH MSB	CP	(HL)		; is above $HIGH ?	POP	HL		;	RET	NC		; return if yesL0B36	LD	A,(BSYFLG$)	; get busy flag	ADD	A,A		; bit 7 set?	RET	C		; return if yes	LD	(L0A7B),HL	; put Break hook vector at end of KI int handler	RET			; done;;	INT caller vector;L0B3F	DB	00H		;LSBL0B40	DB	00H		;MSB	;Debug hook@DBGHK	RET@DEBUG	PUSH	AF	LD	A,97H	RST	28HEXTDBG$	DW	ORARET@ORARET@	OR	A	RET	;Lookup and translate arrow keysLKUPARW	LD	HL,LKPARWT	;translation table for arrow keys	;lookup byte in vector tableLOOKUP_	INC	(HL)		;end of table?	JR	Z,L0B59		;jump out of loop if yes	DEC	(HL)		;restore end of table marker	CP	(HL)		;is key code matching	INC	HL		;	JR	Z,GTHL@HL	;if yes, get A @ HL	INC	HL		;else point to next	INC	HL		;	JR	LOOKUP_		;check next entryL0B59	DEC	(HL)		;restore end of table marker	RET	;Get A and HL @ HLGTHL@HL	LD	A,(HL)	INC	HL	LD	H,(HL)	LD	L,A	;2nd int vector (TODO: RET)INTVC2$	RET	;translation table for arrow keysLKPARWT	DB	1CH		; Left arrow	DW	0008H	DB	1DH		; Right arrow	DW	0009H	DB	1EH		; Up arrow	DW	000BH	DB	1FH		; Down arrow	DW	000AH	DB	0FFH		; End of table@UPPER	CP	61H		; 'a'	RET	C	CP	7BH		; '{'	RET	NC	SUB	20H	RET;;	Type ahead buffer area;TYPBUF	EQU	0FF80H		;Location in high system RAM;KILAST	EQU	$-1	END