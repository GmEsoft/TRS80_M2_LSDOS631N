;****************************************************************;* Filename: SYSINIT4/ASM					*;* Rev Date: 30 Nov 97						*;* Revision: 6.3.1						*;****************************************************************;* Initialization part of SYSRES				*;*								*;****************************************************************;;	Miscellaneous equates for initialization.;;--> Model 4 only	IF	@MOD4TRKREG	EQU	0F1H		;FDC track registerKB1	EQU	0F401H		;Keyboard row 1KB67	EQU	0F460H		;Keyboard rows 6 & 7KB7	EQU	0F440H		;Keyboard row 7	ENDIF;<-- Model 4 only;--> Model II only	IF	@MOD2TRKREG	EQU	0E5H		;FDC track register	ENDIF;<-- Model II onlyBOL	EQU	01DH		;Beginning of line;;--> Model II only	IF	@MOD2$IPLCF1	EQU	2302H		;Boot sector config word 1 (offset 02)$IPLCF2	EQU	2304H		;Boot sector config word 2 (offset 04)	ENDIF;<-- Model II only;;; 	Cursor positions for various things in SYSINIT4;	IF	@PCERV;DATEROW EQU	5		; Row location of DATEDATECOL EQU	0		; Col location of DATETIMEROW EQU	6		; Same for TIMETIMECOL EQU	0SYSGROW EQU	8DINIROW EQU	8PACKROW EQU	2PACKCOL EQU	0VERROW	EQU	2VERCOL	EQU	64;	ELSE;;	Use old positions for all that stuff;DATEROW EQU	21		; Row location of DATEDATECOL EQU	27		; Col location of DATETIMEROW EQU	22		; Same for TIMETIMECOL EQU	27SYSGROW EQU	21		; Row for "*SYSGEN*"DINIROW EQU	21PACKROW EQU	2		; Where pack name shows upPACKCOL EQU	30		; Was 20 under 6.3.0VERROW	EQU	2		; Dos version locationVERCOL	EQU	40		; Would be 30 under 6.3.0;	ENDIF;	ORG	1E00H+START$;;--> Model 4 only	IF	@MOD4SYSINI4	DI	LD	HL,@RSTNMI	; Reset NMI vector to	LD	(@NMI+1),HL	;   SYSRES's needs	ENDIF;<-- Model 4 only;--> Model II only	IF	@MOD2SYSINI2	LD	SP,STACK$	IN	A,(0FFH)	RLCA			;IN($FF):7 -> C	IN	A,(0FCH)	;IN($FC) = keyboard (?)	JR	C,L1E0C		;Skip if C (key pressed?)	OR	0FFH		; else Key <- $FFL1E0C	AND	7FH		;Mask high bit	CALL	@UPPER		;To upper case	LD	($IPLKEY),A	;Save for later use	CALL	INITHRD		;Initialize IM 2 int handling & hardware	CALL	INICRTC		;Initialize the CRTC	LD	HL,($IPLCF1)	;Boot sector config word 1 (offset 02)DIRCYL$	EQU	$-2BOOTST$	EQU	$-1	LD	(DIRCYL$),HL	;Directory cylinder	LD	HL,($IPLCF2)	;Boot sector config word 2 (offset 04)MAXCYL$	EQU	$-2FLAG_2$	EQU	$-1	LD	(MAXCYL$),HL	;MAXCYL - 22H	CALL	@MSET7		;Set bit 7 of MODOUT$: Enable *DO RAM	ENDIF;<-- Model II only;	IF	@PCERV;;	Changes for Pete Cervasio's logo stuff - keep the code the same;	as much as possible, even though a simpler bit of code would;	work just as well...;	LD	HL,PAKNAM$+14	;Point to O/S revision info	LD	DE,VERROW*80+VERCOL+CRTBGN$	LD	BC,2		; 2 chars to move	LDIR			; Display the info...	LD	C,8	INC	DE	INC	DE	DW	0		; Take the space of the LDIR;	ELSE;	LD	HL,PAKNAM$	; Point to disk pack name	LD	DE,PACKROW*80+PACKCOL+CRTBGN$	LD	BC,8	LDIR			; Move pack name to screen	LD	C,8		; B already holds a 0	INC	DE		; Leave two spaces	INC	DE	LDIR;	ENDIF;;---> 6.3.1 changes from version 6.2.0 in "The Source";	INC	DE	INC	DE		; Leave two more spaces	LD	C,18		; 18 characters	LD	HL,SERIAL$	; Point to message area	IF	@BLD631		;===> Since 6.3.1	NOP			; 6.3.0 LDIR to put the	NOP			;  serial # up on screen	ELSE			;<==> Before 6.3.1	LDIR			; put the serial # up on screen	ENDIF;--> Model II only	IF	@MOD2	CALL	@MRES7		;Disable *DO RAM	ENDIF;<-- Model II only;;<--- end of 6.3.1 changes;;	Initialization routines;	XOR	A		;Clear out stack area;--> Model 4 only	IF	@MOD4	LD	HL,STACK$+1	;Start STACK+1CLRLOOP DEC	L		;Move down a byte	LD	(HL),A		;Now loop and fill	ENDIF;<-- Model 4 only;--> Model II only	IF	@MOD2	LD	HL,STACK$	;Start STACKCLRLOOP LD	(HL),A		;Now loop and fill	DEC	L		;Move down a byte	ENDIF;<-- Model II only	JR	NZ,CLRLOOP	;  with zero bytes;;--> Model 4 only	IF	@MOD4	IM	1		;Set the interrupt mode	LD	SP,STACK$	;Set the stack area	XOR	A	LD	(LBANK$),A	;Set logical bank #	OUT	(0E4H),A	;Disable INTRQ & DRQ	ENDIF;<-- Model 4 only;--> Model II only	IF	@MOD2	LD	(LBANK$),A	;Set logical bank #	ENDIF;<-- Model II only;	LD	HL,S1DCB$ZERDCB	LD	(HL),A		;Zero spare DCB area	INC	L	JR	NZ,ZERDCB;;--> Model 4 only	IF	@MOD4	LD	A,(MODOUT$)	;Set high speed	OUT	(0ECH),A	;  and external BUS	LD	A,(WRINT$)	OUT	(0E0H),A	;Enable RTC interrupts	LD	A,(OPREG$)	;Set memory configuration	LD	B,A	LD	A,0A7H		;Value for AUX/RAM	LD	C,@OPREG	;Set memory mgt port	OUT	(C),B		;Bring up regular RAM	LD	HL,-1		;Check for extended RAM	LD	(HIGH$),HL	ENDIF;<-- Model 4 only;--> Model II only	IF	@MOD2	LD	BC,0800HL1E5B	CALL	TSTXRAM		;Test extended RAM @ bank B, $8000 and $C000	RL	C		;Put bit for available bank	DJNZ	L1E5B		;Test Previous bank	LD	HL,0FFFFH	;Size main RAML1E65	CALL	TESTRAM		;Test if RAM @HL (M2)	JR	Z,L1E70		;Exit if exists	LD	A,H		;Sub $2000 (8K)	SUB	20H		;	LD	H,A		;	JR	L1E65		;Test previous 8K blockL1E70	LD	(HIGH$),HL	ENDIF;<-- Model II only	LD	(PHIGH$),HL;;	Check the banks;;--> Model 4 only	IF	@MOD4	LD	D,(HL)		;Save what's in RAM	LD	(HL),55H	;Stuff in regular RAM	OUT	(C),A		;Switch in alt RAM	LD	E,(HL)		;Save the byte there, too	LD	(HL),A		;Stuff alt RAM	OUT	(C),B		;Back to reg RAM	CP	(HL)		;What's there now?	LD	(HL),D		;Put reg RAM byte back	OUT	(C),A		;Back to alt RAM	LD	(HL),E		;Restore original byte	OUT	(C),B		;Back to reg RAM	LD	A,0FEH		;Init BAR$ for bank 0	JR	Z,MZMZ01	;Bypass if only 64k	LD	A,0F8H		;Init BAR$ for bank 0-2MZMZ01	LD	(BAR$),A	;Load bank available ram	ENDIF;<-- Model 4 only;--> Model II only	IF	@MOD2	LD	A,C		;Available banks	LD	(BAR$),A	;Load bank available ram	ENDIF;<-- Model II only	LD	(BUR$),A	;Load bank used ram;--> Model 4 only	IF	@MOD4	LD	A,(FEMSK$)	;Get port FEh mask	OUT	(0FEH),A	; and set it	DC	3,0		;Space for a jump or call	ENDIF;<-- Model 4 only;--> Model II only	IF	@MOD2	XOR	A	LD	(LBANK$),A	ENDIF;<-- Model II only;;	Update DCT$ info for SYSTEM drive;	LD	A,(BOOTST$)	;Get boot step rate	AND	3		;Strip all but it	LD	B,A		;Save temporarily	LD	HL,DCT$+3	;Point to DCT step	LD	A,(HL)		;Get DCT step	AND	0FCH		;Strip step rate	OR	B		;Merge boot step	LD	(HL),A		;Update DCT	IN	A,(TRKREG)	;Update DCT with current	LD	(DCT$+5),A	;  track position of head;;--> Model 4 only	IF	@MOD4	LD	DE,KIDCB$	;Flush type ahead, init ptrs	LD	A,3	CALL	@CTL	EI			;Interrupts on	ENDIF;<-- Model 4 only;--> Model II only	IF	@MOD2	LD	A,(DIRCYL$)	LD	(0479H),A	;DCT0 DIRCYL	LD	HL,0474H	;DCT0 FLAG-2 b5=Double Sided Floppy	LD	A,(FLAG_2$)	BIT	5,A	JR	Z,L1EA6	SET	5,(HL)		;Set Double SidedL1EA6	DEC	HL		;Point to DCT0 FLAG-1	AND	40H		;Test for double density	LD	BC,270FH	;Single density config				;16 sect/trk, 8 sect/gran, 2 gran/trk	JR	Z,L1EB1		;Skip if single density				;30 sect/trk, 10 sect/gran, 3 gran/trk	LD	BC,491DH	;Doubke density configL1EB1	LD	(0477H),BC	;Store config in DCT0+7 and DCT0+8	OR	(HL)		;Put density flag in DCT0 FLAG-2	LD	(HL),A		;	LD	A,(MAXCYL$)	;	ADD	A,23H		;	DEC	A		;Compute MAXCYL = (L1E21)+22H	LD	(0476H),A	;Store MAXCYL in DCT0	ENDIF;<-- Model II only;;	Get CONFIG status & set ZERO byte;	LD	HL,ZERO$	LD	A,(HL)		;Set to NOP if SYSGENed	LD	(HL),0		;Make always zero byte	PUSH	AF		;Save SYSGEN flag;;	Check if date prompt is to be suppressed;	LD	A,(DTPMT$)	;No prompt for DATE?	OR	A;;	Check on currency of date;	LD	HL,DATE$	;Point to year	LD	C,(HL)		;Save in reg C	LD	(HL),0		;  while resetting to zero	INC	HL		;Bump to day	LD	B,(HL)		;  and save in reg B	LD	(HL),0		;  while resetting to zero	INC	HL		;Bump to month	LD	A,(HL)		;Save month to A	LD	(HL),0		;  while resetting to zero	JP	NZ,TIMIN	;Check time if DATE=OFF	LD	L,CFGFCB$+31&0FFH ; Reset pointer;	IF	@INTL	LD	(HL),B		;Stuff day	DEC	HL	LD	(HL),A		;Stuff month	ELSE	LD	(HL),A		;Stuff month	DEC	HL	LD	(HL),B		;Stuff day	ENDIF;	DEC	HL	LD	(HL),C		;Stuff year	EX	DE,HL		;Point DE to CFGFCB$+29	DEC	A		;Check for month range <1-12>	CP	12		;Okay if 0-11 now	JR	C,DATIN1;DATIN	LD	HL,DATEROW<8!DATECOL	;Set video row, col	LD	DE,DATEPR	;DATE? question	LD	BC,8<+8!'0'	;Set buff len & char	CALL	GETPARM		;Get response	JR	NC,DATIN	;Jump on format errorDATIN1	LD	A,(DE)		;Is year a leap year?;--> 6.3.1 changes start	IF	@BLD631	IF	@BLD631L	;---> Since changes for 6.3.1L	CP	80		;Past 1980?	ELSE			;<-->	CP	12		;Past 1912?	ENDIF			;<---	JR	NC,DATIN2	ADD	A,100		;Change to 20xx if not	LD	(DE),A	ENDIF;<-- 6.3.1 changes doneDATIN2	LD	C,A		;Save year for later	SUB	80		;Reduce for range test	IF	@BLD630		;===> Since 6.3.0	IF	@BLD631L	;---> Since changes for 6.3.1L	CP	100		; Check year range (up to 2079)	ELSE			;<-->	CP	32		; Check year range (6.2 was 8) (up to 2011)	ENDIF			;<---	ELSE			;<==> 6.2	CP	8		; Check year range (up to 1987)	ENDIF			;<===	JR	NC,DATIN	AND	3	LD	A,28		;Init February	JR	NZ,NOTLEAP	LD	HL,DATE$+3+1	;Set leap flag	SET	7,(HL)	INC	A		;Feb to 29 daysNOTLEAP LD	HL,MAXDAY$+2	;Set Feb max day #	LD	(HL),A;	IF	@INTL	NOP			;Keep same length	ELSE	INC	DE		;Bump to day	ENDIF	INC	DE		;Bump to month & get it	LD	A,(DE)	LD	B,A		;Save	DEC	A	CP	12		;Range check	JR	NC,DATIN	;Go if error	DEC	HL		;Point to Jan entry	ADD	A,L		;Index the month	LD	L,A;	IF	@INTL	INC	DE		;Point to day	ELSE	DEC	DE		;Point to day	ENDIF;	LD	A,(DE)		;Get day entry	DEC	A		;Reduce for test (0->FF)	CP	(HL)	JR	NC,DATIN	;Go if too large (or 0);;	Range checks okay - move into DATE$;	LD	HL,DATE$+2	INC	A		;Compensate for DEC A	LD	(HL),B		;Stuff month	DEC	L	LD	(HL),A		;Stuff day	DEC	L	LD	(HL),C		;Stuff year;;	Date is in DATE$ - display it;	LD	A,C		;Get year	PUSH	AF		;  and save it	AND	3		;Check on leap year	LD	HL,MAXDAY$+2	;Init & adj Feb as	LD	(HL),28		;  required	JR	NZ,$+3	INC	(HL)		;Bump to 29	LD	A,(DATE$+2)	;Get month and xfer	LD	B,A		;  it to B	LD	A,(DATE$+1)	;Get day of month;;	Compute day of year and day of week;	LD	L,A		;Start off with days	LD	H,0		;  in this month	LD	DE,MAXDAY$DAYLP	LD	A,(DE)	ADD	A,L		;8 bit add to 16 bit	LD	L,A	ADC	A,H		;Add high order & carry	SUB	L		;Subtract off low order	LD	H,A		;Update high order	INC	DE	DJNZ	DAYLP	EX	DE,HL		;Move day of year to DE	LD	HL,DATE$+3	;Store it	LD	(HL),E	INC	HL	LD	A,D		;Get bit "8"	OR	(HL)		;  and OR it in	LD	(HL),A		;Then put it back	EX	DE,HL		;Get DOY back in HL	POP	AF		;Pop the year and mask	SUB	80		;Compute DOW offset (6.2 was AND 7)	LD	E,A	ADD	A,3	RRCA	RRCA	IF	@BLD631	;===> Since 6.3	IF	@BLD631L	;---> Since 6.3.1L	AND	3FH		; 6.3.1L change	ELSE			;<-->	AND	0FH		; 6.3.1 change - 6.2 was 07H	ENDIF			;<---	ELSE			;<==> Version pre-6.3	AND	7		;can be 0-5	ENDIF	ADD	A,E	LD	E,A		;And add it in	LD	D,0		;Add into HL	ADD	HL,DE	INC	HL		;Start in right place;--> 6.3.1 changes	LD	A,7	CALL	@DIV16		;Divide by 7	INC	A;<-- 6.3.1 changes;What was the code before 6.3.1?	LD	B,A		;Save in reg B	RLCA			;Shift to bits 1-3	LD	C,A		;Save temporarily	LD	HL,DATE$+3+1	LD	A,(HL)		;Pack into field	AND	0F1H	OR	C	LD	(HL),A	PUSH	BC	LD	HL,DATEROW<8!DATECOL	;Video row/col	LD	B,3		;Position cursor	CALL	@VDCTL	POP	BC	LD	HL,DAYTBL$	CALL	DSPMDY		;Write out the DAY	LD	A,','	CALL	@DSP	LD	A,' '	CALL	@DSP	LD	A,(DATE$+2)	;Get month number	LD	B,A	LD	L,MONTBL$&0FFH	;Set HL to month table;;	Another custom mod - month displayed slightly differently;	when @PCERV is enabled.;	IF	@PCERV	CALL	DSPMDY		;Add in the spaces if @PCERV	ELSE	CALL	DSPMON		;Write out the month name	ENDIF;	LD	A,' '		;Space after the name	CALL	@DSP	LD	A,(DATE$+1)	;Get day	DEC	B		;From 0 to X'FF'DIV10	INC	B		;Divide by 10	SUB	10		;  with quotient in B	JR	NC,DIV10	PUSH	AF		;Save remainder (-10)	LD	A,B		;Get quotient	ADD	A,'0'		;Change to ASCII	CP	'0'		;Zero?	CALL	NZ,@DSP		;Display if not	POP	AF		;Get back remainder	ADD	A,'0'+10	;Change to ASCII	CALL	@DSP		;Display it;--> 6.3.1 changes	IF	@BLD631		;===> Since 6.3.1	LD	A,(DATE$)	;Get year digits (97?)	LD	HL,1900		;Init to 1900	ADD	A,L		;Add in base year low	LD	L,A		;Save back in L	ADC	A,H		;Add in high byte of year	SUB	L		;Drop extra	LD	H,A		;And put in H	LD	DE,PARTYR+1	;Buffer area	CALL	@HEXDEC		;Convert to decimal	LD	HL,PARTYR	;Point to buffer	CALL	@DSPLY		;And display it.	ELSE			;<==> Before 6.3.1	SUB	80-'0'		;Offset only and convert to ascii	LD	L,'8'		;init to 198x	CP	10+'0'		;In 1980's?	JR	C,WAS80		;Go if so	INC	L		;change to 199x	SUB	10		;Sub off decadeWAS80	LD	H,A		;set ones digit	LD	(PARTYR+4),HL	;stuff into dsplay string	LD	HL,PARTYR	CALL	@DSPLY	ENDIF			;<=== Before 6.3.1;<-- 6.3.1 changes;;	Prompt for time;TIMIN	LD	A,(TMPMT$)	;Prompt for time?	OR	A;--> Model 4 only	IF	@MOD4	JR	NZ,M1FEA	;Skip if not	ENDIF;<-- Model 4 only;--> Model II only	IF	@MOD2	JR	NZ,SELDCT	;Skip if not	ENDIF;<-- Model II only;--> 6.3.1 changesTIMIN0	LD	B,3		;3 bytes to change	LD	HL,00FFH	;Top of first RAM pageM1FB8	LD	(HL),0		;Clear those bytes out	DEC	HL	DJNZ	M1FB8	LD	A,0FFH		;Set byte in code for	LD	(M20EE+1),A	;  comparison;Code before 6.3.1?;<-- 6.3.1 changes	LD	HL,TIMEROW<8!TIMECOL ;Row/col set	LD	DE,TIMEPR	;Prompt message	LD	BC,8<+8!'0'	;Len and separ char	CALL	GETPARM	JR	NC,TIMIN0	;Loop on format error	LD	HL,CFGFCB$+31	LD	A,23		;Max hour value	CP	(HL)		;Test hour range	JR	C,TIMIN0	DEC	HL	LD	A,59		;Max minute value	CP	(HL)		;Test minutes	JR	C,TIMIN0	DEC	HL	CP	(HL)		;Test seconds	JR	C,TIMIN0	LD	DE,TIME$	;Move time value	LD	BC,3		;  into the TIME$ field	LDIR;--> Model 4 only	IF	@MOD4;--> 6.3.1 changesM1FEA	LD	B,80H		;Add a short pause	CALL	@PAUSE;<-- 6.3.1 changes	ENDIF;<-- Model 4 only;;	Check on any auto command;SELDCT	LD	HL,INBUF$	LD	A,(HL)		;Get 1st byte of AUTO	CP	'*'		;Unbreakable AUTO command?	JR	NZ,CKDCR	INC	HL	LD	A,0E6H		;Set break bit in flag by	LD	(STUB1+1),A	;  changing RES 4,(SFLAG$)				;  to SET 4,(SFLAG$)	JR	AUTO?;--> Model 4 only	IF	@MOD4GETKB17 CALL	ENADIS_DO_RAM	LD	A,(KB1!KB7)	;Scan rows 1 and 7	RETCKDCR	CALL	GETKB17		;Strobe keyboard	BIT	4,A		;Is 'D' pressed	ENDIF;<-- Model 4 only;--> Model II only	IF	@MOD2CKDCR	LD	A,($IPLKEY)	;Get next key	CP	44H		;Is 'D' pressed	ENDIF;<-- Model II only	PUSH	HL		;Save auto command pointer	LD	HL,@ABORT	;Get abort address	EX	(SP),HL		;Swap them around;--> Model 4 only	IF	@MOD4	JP	NZ,@DEBUG	;DEBUG on <D>	ENDIF;<-- Model 4 only;--> Model II only	IF	@MOD2	JP	Z,@DEBUG	;DEBUG on <D>	ENDIF;<-- Model II only	POP	DE		;Stack integrity;--> Model 4 only	IF	@MOD4	CPL	AND	1		;No auto if <ENTER>	ENDIF;<-- Model 4 only;--> Model II only	IF	@MOD2	CP	0DH		;No auto if <ENTER>	JR	Z,NOAUT1	CP	03H		;No auto if <BREAK>	ENDIF;<-- Model II only	JR	Z,NOAUT1AUTO?	LD	A,(HL)		;Any auto command?	CP	CR		;None if equalNOAUT1	POP	DE		;Get back SYSGEN flag	LD	A,D		;  and move to reg A	LD	DE,@EXIT	;Where to go after boot	LD	BC,0		;Init BC(HL)=0 for @EXIT	JR	Z,NOAUT		;Go if no AUTO	PUSH	HL		;Save buffer pointer	LD	HL,CURSET	;Point to cursor setting	INC	(HL)		;Bump it down a line	POP	HL		;Recover INBUF$ pointer	LD	DE,@CMNDI	;Low order of @CMNDI	PUSH	DE		;Save on stack for return	LD	B,H		;Put INBUF$ on stack	LD	C,L		;  for @CMNDI	LD	DE,@DSPLY	;But do this firstNOAUT	PUSH	DE		;Put on stack for RET	PUSH	BC		;Either INBUF$ or 0	LD	HL,STUB	LD	DE,MOD3BUF+80	;Must move out of way;--> Model 4 only	IF	@MOD4	LD	BC,STUBLEN	;  amout to move	ENDIF;<-- Model 4 only	PUSH	DE		;Add RET vector to stack;--> Model II only	IF	@MOD2	LD	BC,STUBLEN	;  amout to move	ENDIF;<-- Model II only	LDIR			;Move stub up;--> Model 4 only	IF	@MOD4	CALL	GETKB67	ENDIF;<-- Model 4 only	LD	DE,DCT$		;Set up to move DCTs	LD	HL,MOD3BUF	;  from configed area;--> Model 4 only	IF	@MOD4	LD	BC,80		;Count for DCTs (10*8)	ENDIF;<-- Model 4 only;--> Model II only	IF	@MOD2	LD	C,80		;Count for DCTs (10*8)	ENDIF;<-- Model II only	EXX			;Keep in alternate set;--> Model 4 only	IF	@MOD4	AND	82H		;Load config if zero	RET	NZ		;No config > go back	ENDIF;<-- Model 4 only;--> Model II only	IF	@MOD2	OR	A		;Load config if zero	JR	NZ,L208C	;No config => go back	LD	A,00H$IPLKEY	EQU	$-1	CP	03H		;<BREAK> (?)	JR	Z,L208C		;Exit if yes	CP	08H		;<Left> (?)	JR	Z,L208C	ENDIF;<-- Model II only	LD	HL,SYSGROW<8	;Position the cursor	LD	B,3	CALL	@VDCTL	LD	HL,CONFIG$	;Show sysgen message	CALL	@DSPLY	LD	DE,CFGFCB$	;Set up to load CONFIG/SYS	JP	@LOAD;;--> Model II only	IF	@MOD2L208C	OR	0FFH	RET;CONFIG$ DB	1DH,'** SYSGEN **',03	ENDIF;<-- Model II only;--> Model 4 only	IF	@MOD4CONFIG$ DB	'** SYSGEN **',03;;GETKB67 LD	HL,KB67		;Check CLEAR key	LD	C,A	CALL	ENADIS_DO_RAM	LD	A,C	OR	(HL)		;Key down OR not SYSGENed	RET	ENDIF;<-- Model 4 only;;	Final initialization code;STUB	LD	HL,SFLAG$STUB1	RES	4,(HL)		;Test or set BREAK bit				;Without changing Z/NZ	JR	NZ,NOTSG	;Go if no SYSGEN found;--> Model 4 only	IF	@MOD4	LD	HL,MODOUT$	;Get pointer to port mask	LD	A,(HL)		;Get mask byte	OUT	(0ECH),A	;Speed it up	ENDIF;<-- Model 4 only	EXX			;Set to move DCTs	LDIR			;Move 'em;--> Model 4 only	IF	@MOD4	CALL	@ICNFG		;Init config	ENDIF;<-- Model 4 only;--> Model II only	IF	@MOD2	LD	A,(LLEN$)	;80/40 chars per line	CP	50H		; 'P'	JR	Z,L20BF	LD	C,17H	OR	A	CALL	@DODVR	LD	C,1CH	OR	A	CALL	@DODVR	LD	C,1FH	CALL	@DODVRL20BF	CALL	CRSON@		;Turn on the cursor (14)	LD	HL,(CURSET)	LD	B,03H	CALL	@VDCTL		;@VDCTL	CALL	@ICNFG	ENDIF;<-- Model II onlyNOTSG;	no SYSGEN found;--> Model 4 only	IF	@MOD4	LD	C,7	ENDIF;<-- Model 4 only;--> Model II only	IF	@MOD2	LD	A,03H	OR	A	CALL	TYPAHD@		;in KIDVR2/ASM	LD	C,07H	ENDIF;<-- Model II onlySETCYL0	CALL	@GTDCT		; Get drive's DCT	BIT	3,(IY+3)	; If hard drive, don't stuff FF	JR	NZ,NOFF		;   and don't restore;--> Model 4 only	IF	@MOD4	LD	(IY+5),0FFH	; Set in case no restore	ENDIF;<-- Model 4 only;--> Model II only	IF	@MOD2	LD	(IY+5),4CH	; Set in case no restore	ENDIF;<-- Model II only	LD	A,(RSTOR$)	; Restore drives at startup?	OR	A	CALL	Z,@RSTOR	; Restore drives 1-7NOFF	DEC	C		; Next drive down	JR	NZ,SETCYL0	; Loop for # of drives	LD	HL,DINIROW<8	; Where the cursor should wind upCURSET	EQU	$-1	LD	B,3	CALL	@VDCTL		; Set cursor position;--> Model 4 only	IF	@MOD4;;	Detect Model 4 or 4P and adjust TFLAG$;	Look at "MODEL" at 4018h.  If so, M4P;	LD	DE,'OM'		; Init DE to "MO"	LD	HL,(4018H)	; Get 4P rom "leftover"	SBC	HL,DE		; Check if it's "MO"	LD	A,4		; Init to Model 4 Reg.	JR	NZ,MOD4REG	;   and go if not	LD	A,5		; Change to Mod 4PMOD4REG LD	(TFLAG$),A;	LD	HL,@RST38	; Point to RST vector and	LD	(HL),0C3H	;   activate task processor	ENDIF;<-- Model 4 only	POP	HL		; Pop INBUF$	RET			; To @CMD or @DSPLY,@CMNDI;;--> Model 4 only	IF	@MOD4	DC	12,0		; Space for more code	ENDIF;<-- Model 4 only;--> Model II only	IF	@MOD2	DC	2,0		; Space for more code	ENDIF;<-- Model II onlySTUBEND EQU	$STUBLEN EQU	STUBEND-STUB;;	Date and time promptingGETPARM PUSH	BC		; Save separator char	PUSH	DE		; Save message pointer	LD	B,3	CALL	@VDCTL		; Set cursor position	POP	HL		; Recover message pointer	CALL	@DSPLY		;   and display it	LD	HL,OVERLAY	; Input buffer location	POP	BC		; Get max length back	PUSH	BC	CALL	@KEYIN		; Get user entry	XOR	A	OR	B		; Anything entered?	POP	BC;---> 6.3.1 changes	JR	NZ,M20F4	; Go if something enteredM20EE	LD	A,0		;   else set return	OR	A		;   Z/NZ status	RET	ZM20F2	SCF			; Set carry flag	RET			;   and return;<--- 6.3.1 changesM20F4	PUSH	BC	LD	B,40H	CALL	@PAUSE		; To let finger off	POP	BC;;	Routine to parse DATE entry;PARSDAT LD	DE,CFGFCB$+31	;Point to buffer end	LD	B,3		;Process 3 fieldsPRSD1	PUSH	DE		;Save pointer;;	Routine to parse a digit pair;	CALL	PRSD3		;Get a digit	JR	NC,PRSD2	;Jump if bad digit	LD	E,A		;Multiply by ten	RLCA			;*2	RLCA			;*4	ADD	A,E		;*5	RLCA			;*10	LD	E,A		;Save back in E	CALL	PRSD3		;Get another digit	JR	NC,PRSD2	;Jump on bad digit	ADD	A,E		;Accumulate new digit	LD	E,A		;Save 2-digit value	SCF			;Show valid	LD	A,E		;Xfer field valuePRSD2	POP	DE		;Recover pointer	RET	NC		;Ret if bad digit pair	LD	(DE),A		;Else stuff the value	DEC	B		;Loop countdown	SCF	RET	Z		;Ret when through	DEC	DE		;Backup the pointer	LD	A,(HL)		;Ck for valid separator	INC	HL		;Bump pointer	CP	':'		;Check for colon	JR	Z,PRSD1		;Loop if match	CP	C		;Separator char required	JR	NC,PRSD4	;Exit if bad char;---> 6.3.1 changes	CP	0DH		;Enter?	JR	NZ,PRSD1	;Loop if not	LD	A,B		;Get char count	DEC	A		;Decrement it	JR	NZ,PRSD1	;Loop if not done	LD	A,(M20EE+1)	;Get value from code	OR	A		;Is it zero?	JR	Z,PRSD1		;Loop if it is	SCF			;Else set carry	RET			;  and return;Previous code???;<--- 6.3.1 changesPRSD3	LD	A,(HL)		;Get a digit	INC	HL	SUB	30H		;Convert to binaryPRSD4	CP	10	RET;;	Routine to display month or day of week;DSPMDY	PUSH	HL		;Print 4 spaces	LD	HL,SPACE4$	;Point to string	CALL	@DSPLY	POP	HLDSPMON	DEC	B		;Point to Bth entry	LD	A,L		;  in table	ADD	A,B		;Entries are 3 long	ADD	A,B		;  so have to add B	ADD	A,B		;  three times.	LD	L,A	LD	B,3		;Print 3 charsDSPM1	LD	A,(HL)	INC	HL	CALL	@DSP	DJNZ	DSPM1	RETPARTYR	DB	', 198 ',30,3;	IF	@INTLDATEPR	DB	30,'Date DD/MM/YY ? ',3	ELSEDATEPR	DB	30,'Date MM/DD/YY ? ',3	ENDIF;TIMEPR	DB	30,'Time HH:MM:SS ? ',3SPACE4$	DB	'   ',3,3;;	Under 6.3.0, this was the "Serial# xxxxxxxxxx' string;	IF	@BLD631		;===> Since 6.3.1SERIAL$	DC	21,0		;What was used for Serial # field in 630	ELSE			;<==> Before 6.3.1SERIAL$	DB	'Serial# A400B00110',3EH,99H,0C9H	ENDIF			;<===;M2XXX	DC	32,0;;--> Model II only	IF	@MOD2	;Test extended RAM @ bank B, $8000 and $C000TSTXRAM	LD	A,(MODOUT$)	AND	0F0H	OR	B	CALL	@MODOUT		;set MODOUT$	LD	HL,8000H	CALL	TESTRAM		;Test if RAM @HL (M2)	SCF	RET	NZ	LD	H,0C0H	CALL	TESTRAM		;Test if RAM @HL (M2)	SCF	RET	NZ	OR	A	RET	;Test if RAM @HL (M2)TESTRAM	LD	A,(HL)	CPL	LD	(HL),A	CP	(HL)	CPL	LD	(HL),A	RET	;Initialize IM 2 int handling & hardwareINITHRD	DI	IM	02H	LD	A,09H	LD	I,A	LD	HL,INIDAT0	;Hardware init data (8 blocks)	LD	E,(HL)	INC	HLL2209	LD	B,(HL)	INC	HL	LD	C,(HL)	INC	HL	OTIR	DEC	E	JR	NZ,L2209	LD	A,(MODOUT$)	OUT	(0FFH),A	IN	A,(0FCH)	EI	RET	;Initialize the CRTCINICRTC	LD	HL,CRTC$	;CRTC Initialization data	LD	BC,10FDH	XOR	AL2222	OUT	(0FCH),A	INC	A	OUTI	JR	NZ,L2222	RET	;CRTC Initialization dataCRTC$	DB	63H,50H,55H,08H,19H,00H,18H,18H	DB	00H,09H,67H,07H,00H,00H,00H,00H	;Hardware init data (8 blocks)INIDAT0	DB	08H	;Hardware init data block 1 - port $E2, 5 bytes = PIO Port AINIDAT1	DB	05H,0E2H,00H,0CFH,0F7H,37H,0FEH	;Hardware init data block 2 - port $E3, 3 bytes = PIO Port BINIDAT2	DB	03H,0E3H,00H,0FH,07H	;Hardware init data block 3 - port $F6, 9 bytes = SIO A, chaINIDAT3	DB	09H,0F6H,18H,04H,44H,03H,0E1H,05H	DB	0EAH,11H,18H	;Hardware init data block 4 - port $F7, 11 bytes = SIO B, chINIDAT4	DB	0BH,0F7H,18H,04H,44H,03H,0E1H,05H	DB	0EAH,02H,50H,11H,1CH	;Hardware init data block 5 - port $F0, 4 bytes = CTC, channINIDAT5	DB	04H,0F0H,07H,34H,60H,03H	;Hardware init data block 6 - port $F1, 3 bytes = CTC, channINIDAT6	DB	03H,0F1H,07H,34H,03H	;Hardware init data block 7 - port $F2, 3 bytes = CTC, channINIDAT7	DB	03H,0F2H,07H,34H,03H	;Hardware init data block 8 - port $F3, 2 bytes = CTC, channINIDAT8	DB	02H,0F3H,0C7H,01H	;Hardware init data block 9 - port $C1, 3 bytes (unused?)INIDAT9	DB	03H,0C1H,00H,10H,0CH	ENDIF;<-- Model II only	END