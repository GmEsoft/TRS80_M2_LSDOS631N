;****************************************************************;* Filename: CLOCKS2/ASM					*;* Rev Date: 30 Nov 97						*;* Revision: 6.3.1						*;****************************************************************;* TRS-80 Model II time clock and blinking cursor routines	*;****************************************************************;	SUBTTL	'<Heartbeat and Bank handling>'*MOD;TIMETBL DB	30,60,60,24	;ticks/sec, sec/min, min/hr, hr/dayTIMTSK$	LD	HL,TIMETBL	DEC	(HL)	RET	NZ	LD	(HL),1EHHERTZ$	EQU	$-1	LD	B,03H	EX	DE,HL	INC	DE	LD	HL,TIME$TIMER1	INC	(HL)	LD	A,(DE)	SUB	(HL)	RET	NZ	LD	(HL),A	INC	HL	INC	DE	DJNZ	TIMER1	LD	L,34H		; '4'	LD	DE,0402H	;TODO: equ	INC	(HL)L0730	INC	HL	LD	A,(HL)	DEC	HL	DEC	A	ADD	A,E	LD	E,A	JR	NC,L0739	INC	DL0739	LD	A,(DE)	CP	(HL)	RET	NC	LD	(HL),01H	INC	HL	INC	(HL)	LD	A,(HL)	SUB	0DH	RET	C	LD	(HL),01H	DEC	HL	DEC	HL	INC	(HL)	;int vector (RETINST)@RETINS	RET;;	Clock display processor;DO_CLOCK	LD	C,H	RLCA	LD	HL,CLOCK$	;Clock buffer '..:..:..'	PUSH	HL		;Save buffer address	CALL	@TIME		;Write the current time	POP	HL		;Restore buffer address	LD	E,0F5H		;EOL - 11	LD	C,08H		;8 chars	;Display trace or clock in timer taskDISPINT	LD	A,(BSYFLG$)	;busy flag for int	ADD	A,A		;Check busy flag	RET	C		;Exit if flag set;	IF	@BLD631N	;===> fix SP in DO RAM bug	LD	($DISVSP),SP	;Save stack pointer	PUSH	HL		;Save buffer address	LD	HL,0FFFFH-0F3FCH;Can't exceed F3FCH	ADD	HL,SP		;Check for overflow	POP	HL		;Restore buffer address	JR	NC,$+5		;If not, skip next instr	LD	SP,0360H	;Else switch stack, keeping room at top	ENDIF			;<=== fix SP in DO RAM bug;	LD	A,(MODOUT$)	;Save old MODOUT state	PUSH	AF		;	CALL	@MSET7		;Enable DO RAM	LD	A,(LLEN$)	;80/40 chars per line	ADD	A,E		;Add negative offset	LD	E,A		;	LD	D,0F8H		;DE = DO RAM address	LD	B,00H		;	LDIR			;Write to DO RAM	POP	AF		;Restore old MODOUT state;	IF	@BLD631N	;===> fix SP in DO RAM bug	CALL	@MODOUT		;	LD	SP,$-$		;Get the old stack$DISVSP	EQU	$-2	RET	ENDIF			;<=== fix SP in DO RAM bug;;	set MODOUT$;@MODOUT	LD	(MODOUT$),A	;Save MODOUT state	OUT	(0FFH),A	;Output to MODOUT port	RET			;	;'..:..:..'CLOCK$	DB	'..:..:..'	;Date/Time buffer string;;	Write the date;@DATE	LD	DE,0035H	; Point to last DATE byte	LD	C,2FH		; '/' Date separator	JR	TIME1		; Write the date;;	Write the time;@TIME	LD	DE,002FH	; Point to last TIME byte	LD	C,3AH		; ':' Time separatorTIME1	LD	B,03H		; 3 groups of 2 digitsTIME2	LD	A,(DE)		; Get next 2-digits value	LD	(HL),'0'-1	; Init tens digitTIME3	INC	(HL)		; Increment tens digit	SUB	0AH		; Subtract 10 from number	JR	NC,TIME3	; Loop until negative	ADD	A,'0'+10	; Fix units digit		INC	HL		; Bump to units digit	LD	(HL),A		; Write the digit	INC	HL		; Bump to separator	DEC	B		; Decrement groups counter	RET	Z		; Return if done	LD	(HL),C		; Write separator	INC	HL		; Bump output buffer pointer	DEC	DE		; Next group (backwards)	JR	TIME2		; Iterate;;	Vector to task TRACE_INT;TRACE$	DW	TRACE_INTDO_TRACE EQU	TRACE$;;	TRACE_INT Dynamic trace routine;TRACE_INT	LD	DE,0000H	;Gets the PC value when interruptedPCSAVE$	EQU	$-2	LD	HL,CLOCK$	;Clock buffer '..:..:..'	PUSH	HL		;Save	CALL	@HEX16		;Write PC value as hex	POP	HL		;	LD	E,0EFH		;EOL - 17	LD	C,04H		;4 chars	JR	DISPINT		;Display trace or clock in timer task;;	@HEX16 Put DE as 16-bit HEX to HL;@HEX16	LD	A,D	CALL	@HEX8	LD	A,E;;	@HEX8 Put A as 8-bit HEX to HL;@HEX8	PUSH	AF	RRCA	RRCA	RRCA	RRCA	CALL	L07C1	POP	AFL07C1	AND	0FH	ADD	A,90H	DAA	ADC	A,40H	DAA	LD	(HL),A	INC	HL	RET;;	Vector to task ALIVE (Mod4: in HIMEM by SYS ALIVE);ALVTCB	DW	ALIVE		;IX points here	DB	08H		;ALIVE characterDO_ALIVE EQU	ALVTCB;;	Task ALIVE (Mod4: in HIMEM by SYS ALIVE);ALIVE	LD	A,02H		;Toggle ALIVE indicatorL07D0	EQU	$-1	IF	@BLD631N	;===> Gain 4 bytes	DEC	HL		;Point to indicator (ALIVE-1)	XOR	(HL)		;	LD	(HL),A		;	ELSE			;<==> Old code	XOR	(IX+2)		;	LD	(IX+2),A	;	DEC	HL		;Point to indicator (ALIVE-1)	ENDIF			;<===	LD	E,0FFH		;EOL - 1	LD	C,01H		;1 char	JP	DISPINT		;Display trace or clock in timer task;;	Routine to enable video RAM and change stack if necessary;ENADIS_DO_RAM	LD	(HLSAV),HL	;Save HL but not on the stack	PUSH	AF		;Save AF	POP	HL	LD	(AFSAV),HLL07E7	LD	A,(BSYFLG$)	;TODO: busy flag for int ?	ADD	A,A	JR	C,L07E7	LD	A,(MODOUT$)	;p/u port mask	LD	HL,0C03H	;Can't exceed F3FCH	ADD	HL,SP	JR	NC,L07FF;;	Switch to the system stack;	POP	HL		;Transfer RET address	LD	(SPSAV),SP	;Save stack pointer	LD	SP,0360H	;Keep room at top	PUSH	HL		;Put RET backL07FF	LD	HL,DIS_DO_RAM	;Stack return to disable	EX	(SP),HL		;  video RAM below RET	PUSH	HL	LD	HL,OPREG_SV_AREAOPREG_SV_PTR	EQU	$-2	SET	6,A	JR	NC,L080D	;bypass if NC (no stack switch)	RES	6,A		;Strip bit 6 to use as flagL080D	LD	(HL),A		;Save current state	INC	HL		;Bump ptr	SET	7,A		;Activate DO RAM bit	INC	A		;	DEC	A		;set NZ	JR	DOOPREG		;Set new assignment;;	Routine to disable video RAM;DIS_DO_RAM	LD	(HLSAV),HL	;Save off of stack	PUSH	AF	POP	HL	LD	(AFSAV),HL	LD	HL,(OPREG_SV_PTR)	DEC	HL	LD	A,(HL)		;pick up previous state	BIT	6,A		;Test if we switch stack	RES	7,A		;Disable DO RAMDOOPREG	LD	(OPREG_SV_PTR),HL	RES	6,A		;Make sure flag is cleared	CALL	@MODOUT		;Restore port image and the port	JR	NZ,L0833;;	Switch back to the old stack;L0830	LD	SP,L0830	;Get the old stackSPSAV	EQU	$-2L0833	LD	HL,L0833AFSAV	EQU	$-2	PUSH	HL	POP	AFL0838	LD	HL,L0838HLSAV	EQU	$-2	RET;;	Bank selection SVC handler;	HL -> Transfer address for function B=0;	C  -> Bank request (0-2); set bit 7 to transfer;	B  -> Request function;		0 - Select bank C;		1 - Reset in-use bit of bank C;		2 - Test in-use bit of bank C;		3 - Set in-use bit of bank C;@BANK	PUSH	HL	LD	A,B	LD	HL,LKPBANK	;Lookup table for @BANK services	CALL	LOOKUP_		;lookup byte in vector table	EX	(SP),HL	RET	Z	POP	AF	JP	PERR		;SVC parameter error	;Lookup table for @BANK servicesLKPBANK	DB	00H	DW	@BANK_0	DB	01H	DW	@BANK_1	DB	02H	DW	@BANK_2	DB	03H	DW	@BANK_3	DB	04H	DW	@BANK_4	DB	0FFH@BANK_4	LD	A,(LBANK$)	CP	A	RET@BANK_3	CALL	@BANK_2	RET	NZ	JR	L08C0@BANK_1	CALL	L08A1	RET	NZ	JR	@BANK1_@BANK_2	CALL	L08A1	RET	NZ	JR	@BANK2_@BANK_0	PUSH	HL	LD	HL,8005H	ADD	HL,SP	POP	HL	JP	C,PERR		;SVC parameter error	CALL	L08A1	RET	NZ	LD	A,(MODOUT$)	AND	0F0H	LD	B,A	LD	A,C	AND	7FH	INC	A	OR	B	CALL	@MODOUT		;set MODOUT$	LD	A,(LBANK$)	LD	B,A	LD	A,C	AND	7FH	LD	(LBANK$),A	XOR	C	OR	B	LD	C,A	BIT	7,C	LD	B,00H	RET	Z	EX	(SP),HL	CP	A	RETL08A1	LD	A,C	AND	7FH	CP	08H	JR	C,L08ABL08A8	JP	PERR		;SVC parameter errorL08AB	PUSH	HL	LD	HL,BAR$	JR	L08B5@BANK2_	PUSH	HL	LD	HL,BUR$L08B5	PUSH	BC	CALL	L08DB	LD	A,(HL)	AND	C	POP	BC	POP	HL	JR	NZ,L08A8	RETL08C0	CALL	L08CF	OR	C	JR	L08CA@BANK1_	CALL	L08CF	AND	BL08CA	LD	(HL),A	POP	BC	POP	HL	XOR	A	RETL08CF	POP	AF	PUSH	HL	PUSH	BC	PUSH	AF	LD	HL,BUR$	CALL	L08DB	LD	A,(HL)	RETL08DB	RES	7,C	INC	C	LD	B,01HL08E0	DEC	C	JR	Z,L08E7	SLA	B	JR	L08E0L08E7	LD	A,B	LD	C,A	CPL	LD	B,A	RET;; Keyboard typeahead buffer handling;	peek pending key offset;	if C set (OK), A contains new key offset;	and HL points to the next key in buffer;L08EC	LD	A,(IX+4)	;get GET offset	CP	(IX+3)		;same as PUT offset?	RET	Z		;return if so with Z & NC (no key)L08F3	PUSH	AF		;	LD	L,(IX+0)	;get buffer start address	LD	H,(IX+1)	;	ADD	A,L		;add GET offset	LD	L,A		;	JR	NC,L08FF	;	INC	H		;(should never carry...)L08FF	POP	AF		;recover GET offset	INC	A		;bump GET offset	CP	(IX+2)		;if at end?	RET	C		;return A=offset with C if not	XOR	A		;reset ptr	SCF			;set C	RET			;and return;; Keyboard typeahead buffer handling;	peek pending key offset;	if C set (OK), A contains new key offset;	and HL points to the next free location in buffer;L0908	LD	A,(IX+3)	;get PUT offset	CALL	L08F3		;bump	CP	(IX+4)		;buffer full?	RET	Z		;return with NC (Failed) if yes	LD	(IX+3),A	;save new PUT offset	SCF			;return with C (OK)	RET;	IF	.NOT.@BLD631N	;===> Move after IM2 INT vectorsOPREG_SV_AREA			;OPREG state save area	DC	14,0BSYFLG$	DB	00H		;busy flag for CRT controller/MODOUT	ENDIF			;<===;;	Set bit 7 of MODOUT$: 	Enable *DO RAM;@MSET7	PUSH	AF	LD	A,(MODOUT$)	OR	80H	JR	MODRS		;set/reset MODOUT$;;	Reset bit 7 of MODOUT$: Disable *DO RAM;@MRES7	PUSH	AF	LD	A,(MODOUT$)	AND	7FH	JR	MODRS		;set/reset MODOUT$;;	Set bit 5 of MODOUT$:	RTC interrupts enable;@MSET5	PUSH	AF	LD	A,(MODOUT$)	OR	20H	JR	MODRS		;set/reset MODOUT$;;	Reset bit 5 of MODOUT$:	RTC interrupts disable;@MRES5	PUSH	AF	LD	A,(MODOUT$)	AND	0DFH	;set/reset MODOUT$ MODRS	CALL	@MODOUT		;set MODOUT$	POP	AF	RET;	IF	$.GT.0950H	ERR	'Code overlaps IM 2 int vectors'	ELSE	DC	0950H-$,0	; Filler to align to 0950H	ENDIF;	;1st int vectorINTVC1$	DW	@INTVC2,@INTVC2,@INTVC2,@INTVC2	DW	@INTVC1,@INTVC1,@INTVC1,@INTVC1	DW	0FFFFH,0FFFFH,0FFFFH,@INTKI;	IF	@BLD631N	;===> Moved after IM2 INT vectorsOPREG_SV_AREA			;OPREG state save area	DC	14,0BSYFLG$	DB	00H		;busy flag for CRT controller/MODOUT	ENDIF			;<===;@INTVC1	PUSH	HL	LD	HL,(0042H)	JR	L0972;@INTVC2	PUSH	HL	LD	HL,(0044H)L0972	PUSH	DE	PUSH	BC	PUSH	AF	PUSH	IX	LD	A,(LBANK$)	PUSH	AF	XOR	A	LD	(LBANK$),A	LD	A,(MODOUT$)	PUSH	AF	AND	70H	OR	01H	CALL	@MODOUT		;set MODOUT$	PUSH	HL	LD	HL,L0990	EX	(SP),HL	JP	(HL);L0990	POP	AF	CALL	@MODOUT		;set MODOUT$	POP	AF	LD	(LBANK$),A	POP	IX	POP	AF	POP	BC	POP	DE	POP	HLL099E	EI	RETI;	END